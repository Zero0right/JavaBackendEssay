# 大厂 java后端开发 数据分析 前端开发 

## java基础

### 1. java的特点

- 平台独立性和移植性：归根于Java虚拟机JVM。已编译的Java程序，class文件（字节码）可以在带有JVM的平台上运行。
- 稳健性：强类型语言，扩展编译时检查类型不匹配问题；显示声明，要求严格能捕捉调用错误；try/catch/finally异常处理；

### 2. java和cpp的区别

- java纯粹面向对象；cpp兼容c，面向对象也面向过程；
- java通过JVM可以跨平台；cpp依赖于特定的平台；
- java没有指针，引用可以理解为安全的指针；
- java支持自动垃圾回收；cpp需要手动回收；
- java不支持多重继承，但能实现多个接口；cpp支持多重继承；

### 3. JDK/JRE/JVM三者的关系
 
- JDK：java开发工具包；集成了JRE+java工具+编译器+调试器；
- JRE：java运行时环境；包含JVM和java核心类库；可用于运行java程序，不能用于开发java程序；
- JVM：java虚拟机，是一个在实际计算机硬件和操作系统之上的虚拟计算机，负责执行java字节码；字节码执行、内存管理（垃圾回收）、安全管理、跨平台性、性能优化；

### 4. java程序是编译执行还是解释执行

- 编译型：通过编译器将源程序翻译成机器码；总结：执行速度快、效率高、依靠编译器、跨平台性差；c cpp pascal object-c swift；
- 解释性：翻译成中间代码，再由解释器对中间代码进行解释运行，运行时翻译成机器码；总结：执行速度慢、效率低、依靠解释器、跨平台性好；JavaScript Python erlang php perl ruby
- java源代码先通过javac编译成字节码，在通过jvm将字节码转成机器码；半编译半解释；

### 5. 面向对象和面向过程的区别

- 面向过程：分析解决问题的步骤，用函数将步骤实现，依次调用函数；
- 面向对象：将问题分解成各个对象，分别设计对象，组装成有完整功能的系统；用类实现各个功能模块；

### 6. 面向对象有哪些特性

- 封装、继承、多态、抽象
- 封装：类的方法才能对属性进行操作和访问，减少耦合；
- 继承：子类继承父类的属性和方法，并可以有新的属性和方法；java单继承；增加重用性和易维护性；
- 多态：同一个行为具有多个不同表现形式的能力；实现多态的三要素：继承、重写、父类引用指向子类对象；
  *静态多态性：* 重载实现，相同方法具有不同的参数，做出不同的处理；
  *动态多态性：* 子类中重写父类的方法；
- 抽象：抽象类和抽象方法，只包含方法声明没有具体实现；抽象类不能被实例化；

### 7. java中的基本数据类型

- byte: 8bit char:16bit short:16bit int:32bit float:32bit long:64bit double:64bit boolean

### 8. 为什么不能用浮点型表示金额

- 浮点数：计算机保存的小数是十进制小数的近似值，不是精确值；
- 建议用BigDecimal或者Long表示金额

### 9. 什么是包装类型，为什么需要包装类型

- 包装类型：让基本数据类型有了对象的性质，添加了属性和方法；
- 为什么需要：很多地方需要使用对象而不是基本数据类型，比如集合类中，无法将基本数据int、double等类型放进去，集合容器要求元素是Object类型；

### 10. 装箱和拆箱

- 装箱：将基本类型转化为包装类型
- 插箱：将包装类型转化为基础类型

### 11. String为什么不可变

- 线程安全：由于String的不可变，多个线程可以安全共享同一个String对象；
- 缓存hash值：String对象的hash值经常被使用，将 String 设计为不可变可以缓存 hash 值，提高性能；
- 安全性：String 类被广泛用于作为参数传递给许多 Java 核心库和第三方库中的方法，如果 String 是可变的，可能导致安全漏洞；
- 简化设计：不可变使得代码更加简单且易于理解，避免了因为值的改变而引发的意外；

### 12. String Stringbuffer Stringbuilder区别

-String不可变 另外两种可变；StringBuffer 是线程安全的，内部使用 synchronized 进行同步

### 13. String类的常用方法有哪些

- indexOf() 返回制定字符的索引
- charAt() 返回制定索引处的字符
- replace() 字符串替换
- trim() 去除字符串两段空白
- split() 分割字符串，返回一个分割后的字符串数组
- getBytes() 返回字符串的byte类型数组
- length() 返回字符串长度
- toLowerCase() 将字符串转成小写字母
- toUpperCase() 将字符串转成大写字符
- substring() 截取字符串
- equals() 字符串比较

### 14. 什么是StringJoiner

- java8引入 用于拼接字符串的工具类；
- 自定义分隔符 前缀 后缀
- StringJoiner sj = new StringJoiner(", ", "[", "]");
  sj.add("Apple");
  sj.add("Banana");
  sj.add("Orange");
  String result = sj.toString();
  System.out.println(result); // 输出：[Apple, Banana, Orange]

### 15. new String("xxx")会创建几个对象

- 两个；字符串常量池中创建一个字符串对象，指向xxx；
- new关键字会在堆内存中再创建一个新的字符串对象

### 16. 什么是字符串常量池

- String pool保存着所有字符串字面量，这些字面量在编译时期就确定；
- 位于堆内存中；
- 创建字符串时，JVM检查String pool，如果已在池中，则返回其引用，若不存在，则创建并放入池中，并返回其引用；

### 17. String最大长度是多少

- 受length方法限制，其返回值为int类型，取值上限为2^31-1;
- 最大长度的字符串需要4GB的内存空间;
- 字符串声明+编译后 会以常量的形式进入常量池；
- 字符串常量长度不超过65534；堆内字符串的长度不超过2^31-1;

### 18. Object常见方法

- toString() 返回对象的字符串表示；
- equals(object obj) 比较两个引用变量是否指向同一个对象（内存地址）；
- hashCode 将与对象相关的信息映射成一个哈希值，默认hashcode根据内存地址换算出来；
- clone 实现对象中各个属性的复制，但可见范围是protected；
- getClass 返回对象的运行时类
- notify 唤醒在该对象上等待的单个线程
- notifyAll 唤醒在该对象上等待的所有线程
- wait 导致当前线程等待；

### 19. 浅拷贝和深拷贝

- 浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象
- 深拷贝：拷贝对象和原始对象的引用类型引用不同的对象

### 20. 两个对象的hashCode相同，equals是否一定为true

- hashcode相同，equals不一定相同
- equals返回true,那么hashCode一定相同
- hashcode主要用来高效管理对象并在集合中进行快速查找和存储

### 21. Java创建对象有几种方式

- new语句创建对象
- 使用反射，Class.newInstance()创建对象
- 调用对象的clone()方法
- 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法

### 22. 类实例化的顺序

- 静态属性初始化
- 静态代码块初始化
- 普通属性初始化
- 普通代码块初始化
- 构造方法初始化

### 23. equals和==的区别

- 对于基本数据类型 ==比较值 没有equal方法；
- 对于复合数据类型 ==比较的是存放地址;equals默认的行为是使用==比较对象的引用地址；在许多Java类中，equals方法被重写以比较对象的内容而不是引用地址；

### 24. 常见的关键字

- static 修饰类的成员方法和变量;静态变量和方法，可以直接通过类名访问；
- final 修饰类则不能被继承；修饰方法则不能被子类重写；修饰变量则只能赋值一次；
- this 是一个引用，指向当前对象的实例，可以用来区分实例变量和局部变量；
- super 是一个引用，指向父类的实例

### 25. final finally finalize的区别

- final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承
- finally异常处理语句结构的一部分try-catch-finally，表示代码块总是被执行
- finalizeobject类的方法，一般由垃圾回收器调用

### 26. 方法重载和重写的区别

- 重载：相同方法名，不同的参数列表
- 重写：父类与子类之间，子类对方法进行重写@Override

### 27. 接口与抽象类的区别

- 接口完全抽象，只包含方法的声明和常量的定义；
- 抽象类，包含抽象方法和具体方法，本身不能被实例化
- 一个类可以实现implements多个接口，必须实现接口中声明的所有方法；一个类接口只能继承extend一个抽象类，子类可以选择性实现或覆盖抽象方法；
- 接口没有构造函数；抽象类可以有构造函数；
- 接口只能定义常量，public static final；抽象类可以定义各种类型的字段，实例变量、静态变量；

### 28. 常见的Exception有哪些

*runtimeException*
- 类型转换异常
- 数组越界异常
- 空指针
- 数组存储异常
- 数字格式化异常
- 数学运算异常
*checked exception*
- 反射异常，没有对应的字段
- 类没有找到异常
- 安全权限异常

### 29. error和exception有什么区别

- error JVM无法解决的问题，如何栈溢出、内存溢出等。程序无法处理的错误；
- exception 编程错误或外在因素导致的一般性问题，可以在代码中处理，如空指针异常、数组下标越界；

### 30. 运行时异常和非运行时异常区别

- runtimeException 程序错误导致，应该修正程序避免这类异常发生
- checked exception 由具体的环境导致的异常，读取的文件不存在或文件为空或sql异常。

### 31. throw和throws的区别

- throw 在代码块中手动抛出一个异常对象
- throws 声明方法中可能会抛出的异常

### 32. BIO/NIO/AIO

- 阻塞BIO：每次来一个请求，就分配到线程池中由一个线程处理，如果超过线程池的最大上限，就扔到队列等待；I/O操作是阻塞的；高并发情况下性能较差；
- 非阻塞NIO：引入了通道和缓冲区，非阻塞处理I/O操作；通过selector，一个线程可以管理多个通道的I/O操作，高并发下性能较好；
- 异步非阻塞AIO：不需要线程阻塞等待I/O完成；适用于处理大量并发；相比于NIO，更适合处理文件和网络I/O；

### 33. 守护线程是什么

- 守护线程是运行在后台的一种特殊进程；
- 独立于控制终端并且周期性执行某种任务或等待处理某些发生的事件；
- 在Java中垃圾回收线程就是特殊的守护线程；例如日志记录、定期清理任务；

### 34. 前台线程和后台线程

- 前台线程是程序中明确创建的线程，阻止程序终止，执行重要任务与用户交互；
- 后台线程在程序运行时在后台默默执行，不阻止程序终止，通常执行一些不需要组织程序终止的任务；

### 35. 应用程序 进程 线程

- 一个应用程序可以对应一个或多个进程，每个进程包含了应用程序的一个实例或部分；
- 一个进程可以包含一个或多个线程，线程共享进程的资源，可以并发执行不同的任务；
- 应用程序通过进程启动并运行，进程内部的线程负责实际的任务执行

### 36. java为什么不支持多继承

- java类不支持多继承；类可以通过实现多个接口；
*java不支持多继承原因*
- 如果子类继承多个父类中含有相同的方法或属性，子列不知道具体继承哪个；

### 37. java中实现对象的克隆

- 通过实现cloneable接口并重写clone方法实现浅拷贝；
- 通过序列化和反序列化实现深拷贝；

### 38. 同步和异步的区别

- 同步：阻塞式，调用者发起请求后等待才做完成并返回结果，期间无法进行其它操作；
- 异步：非阻塞，调用者发起一个请求后不需要等待操作完成，而是可以继续执行后续操作；通过回调、轮询或时间触发实现异步；非阻塞：该调用不会阻塞当前线程；

### 39. 序列化和反序列化，应用场景

- 序列化：把对象转换为字节序列的过程称为对象的序列化
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化
- 应用场景：当对内存中的对象进行持久化（磁盘，数据库）或网络传输，都需要序列化和反序列化；

### 40. Serializable的作用 serialVersionUID的作用

- 当一个类实现了Serializable接口后，就可以将该类的对象转换为字节流进行序列化，或者将字节流转换为对象进行反序列化；
- Java会使用serialVersionUID来验证序列化对象的版本是否与当前类的版本匹配。如果不匹配，就会导致反序列化失败；

### 41. static属性为什么不会被序列化

- static属性优先于对象存在，随着类的加载而加载，所以不会被序列化；

### 42. transient关键字的作用

- 该词修饰的变量，在序列化的时候其值会被忽略，在被反序列化后，变量的值被设为初始值，如int:0,对象型：null；

### 43. 什么是反射，应用场景

- 反射：对于任意类，能知道类的所有属性和方法；对于任意对象，能够调用任意方法和属性；
*应用场景*
- JDBC连接数据库使用class.forName()反射加载数据库的驱动程序
- IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法；
- web服务器中利用反射调用sevlet的Service方法；
- jdk动态代理底层依赖反射实现；

### 44. 什么是泛型

- 泛型类Box<T>
- 通过泛型，可以创建通用的数据容器类，用于存储不同IO类型的数据，无需对每种数据类型编写不同的类；

### 45. 如何停止一个正在运行的线程

- 设置标志位；
- interrupt() 加上手动抛异常：使用interrupt方法中断线程，打上停止的标记，调用 Thread.currentThread().isInterrupted()，判断当前线程是否被终止，通常如果isInterrupted返回true的话，会抛一个中断异常；
- 使用stop()方法可以强制终止线程（已废弃）

### 46. 什么是跨域

- 跨域是指从一个域名的网页请求另一个域名的资源；由于同源策略，不允许直接访问；场景：前后端分离模式；
- 同源策略：同源 协议+域名+端口三者相同；有利于保护网站信息；

### 47. 跨域问题如何解决

- @CrossOrigin注解：Springboot，在Controller类上添加一个 @CrossOrigin(origins ="*") 注解就可以实现对当前controller 的跨域访问；可以加到方法上，也可加到入口类；
- proxy代理转发：配置代理服务器，将前端请求先发送到代理服务器，代理将请求转发后端服务；前端和代理之间不涉及跨域，代理与后端之间不存在跨域；
- CORS（Cross-Origin Resource Sharing）配置：后端服务可以在响应中添加CORS头部信息来允许特定的跨域请求。在后端接口的响应中添加Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等头部字段，指定允许的来源、HTTP方法和头部信息。这样浏览器在发起跨域请求时会根据这些头部信息进行验证和授权。

### 48. java中引用和cpp指针的区别

- 空指针与空引用：空指针，指向内存地址为0的指针，表示不指向任何有效对象；引用不能为null，可以指向一个空对象；
- 指针运算和引用操作：cpp：指针可以运算，可以直接访问指针指向的内存地址；java：不允许运算，无法直接访问对象的内存地址；
- 内存管理：cpp：指针需要手动进行内存分配和释放，可能导致内存泄漏和悬空指针；java：引用的内存管理由垃圾回收器自动处理，无需手动管理；
- 安全性：cpp:空指针异常、野指针；java：引用不为null；
- 多级指针和引用链：cpp:多级指针实现多级间接访问；java：通过对象的引用链来访问嵌套对象；

## java集合

### 1. 常见的集合有哪些

- 集合主要由接口Collection和Map派生出来，Collection有三个子接口：List、Set、Queue
- List：有序可重复集合，可直接根据元素的索引来访问；可以插入多个null；
- Set：无序不可重复集合，只能根据元素本身来访问；只允许一个null；
- Queue：队列集合
- Map：key-value对的集合，可根据元素key来访问value
- Set Map容器有基于哈希存储和红黑树两种方式实现；
- Set基于Map实现，Set里的元素值就是Map的键值；

### 2. ArrayList是什么，其扩容机制，遍历ArrayList时移除一个元素？

- 动态数组，容量能够动态增长；可以使用ensureCapacity增加ArrayList实例的容量；
- 本质是计算出新的扩容数组的size后实例化，并将原有数组内容赋值到新数组中；原有的数组会被垃圾回收器回收，释放内存空间；ArrayList通常会选择增加一定的空间来避免频繁扩容，以提高性能；
- foreach删除会导致快速失败问题，可以使用迭代器的remove方法；
  Iterator itr = list.iterator();
  itr.remove();

### 3. ArrayList 和 Vector的区别

- 都是存储对象的动态数组；
- ArrayList在内存不够时扩容为原来的1.5倍；Vector扩容为原来的2倍；
- Vector属于线程安全级别，大多数情况下不使用，效率比较低；

### 4. ArrayList和LinkedList的区别

- 前者基于动态数组实现；后者基于链表实现；
- 通过index访问get和set方法，前者速度优于后者；前者直接通过数组下标找元素；后者需要移动指针遍历元素直到找到为止；
- 新增和删除元素，后者速度优于前者，前者可能需要扩容和赋值数组；后者实例化对象后修改指针即可；

### 5. HashMap

- HashMap使用数组+链表+红黑树实现；链表长度大于8时，会把链表转换为红黑树，红黑树节点个数小于6时才转化为链表，防止频繁的转化；

### 6. 解决Hash冲突的方法？HashMap用的哪种？

- 开放定址法、再哈希法、链地址法；HashMap使用的是链地址法；
- 开放定址法：如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi；开放定址法所需要的Hash表的长度要大于等于所需要存放的元素；只能在删除的节点上做标记，不能。

### 7. hash算法

- 取key的hashCode值，高位运算（减少冲突）、取模运算；
- jdk1.8中，通过hashcode()的高16位异或低16位实现；减少冲突同时不会有太大的开销；

### 8. 为什么建议设置hashMap的容量

- hashmap有扩容机制，达到扩容条件（hashmap中的元素个数超过临界值）就会扩容；
- 如果不设置初始容量大小，随着元素的不断增加，hashmap会发生多次扩容；每次扩容都需要重建hash表，非常影响性能，所以建议初始化hashmap容量；

### 9. 扩容机制

- 1.8扩容机制：当元素个数大于threshold是，使用2倍容量的数组代替原有数组。采用尾插入的方式将原数组元素拷贝到新数组。

### 10. put方法流程

- 如果table没有初始化就先进行初始化
- 使用hash算法计算key的索引
- 判断索引处是否存在元素，没有就直接插入
- 如果存在元素，一种是链表形式直接遍历到尾端插入，另一种是红黑树按照结构插入；
- 链表的数量大于阈值8，就要转换成红黑树的结构
- 添加成功后会检查是否需要扩容

### 11. 红黑树的特点

- 每个节点或是黑色或是红色
- 根节点和叶子节点是黑色的
- 如果一个节点是红色的，则其子节点必须是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

### 12. 解决hash冲突，为什么先用链表，再转红黑树

- 红黑树需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要；
- 链表元素小于8，可以保证查询性能；当元素个数大于8个并且数组容量大于等于64，会采用红黑树；
- 红黑树搜索时间复杂度为O（logn）,链表为O（n），在n比较大的时候，使用红黑树可以加快查询速度；

### 13. hashmap长度为什么是2的幂次方

- 将HashMap的长度定为2的幂次方，这样就可以使用(n - 1)&hash位运算代替%取余的操作，提高性能。

### 14. hashmap默认加载因子是多少，为什么？

- 当元素个数达到容量乘以加载因子时，hashmap将会扩容；
- 0.75是时间空间成本之间的一个平衡；
- 空间多 时间效率要求高，降低负载因子的值；
- 空间紧张 时间效率要求不高，增加负载因子的值，可以大于1；

### 15. 一般用什么作为hashmap的key

- 由于 String 类型是不可变的，并且已经重写了 hashCode() 和 equals() 方法，非常适合作为 HashMap 的 key；
- 例如 Integer、Long、Double 等，这些类也已经重写了 hashCode() 和 equals() 方法
- key用来唯一标识键值对，决定了键值对在hashmap内部的存储位置以及查找方式；

### 16. hashmap为什么线程不安全
- jdk1.7 多线程环境下，扩容可能导致环形链表的出现，形成死循环；
- jdk1.8 多线程环境下，会发生数据覆盖；

## 计算机基础 

### 计算机网络 

### 操作系统 

### 数据库 

### 算法/leetcode

## 真实java面经整理

### 1. websocket是什么

- websocket一种单个TCP连接上进行全双工通信的协议，允许客户端和服务器之间实时双向数据传输；
- 与传统的http请求响应模型不同，websocket通过保持长连接，使得服务器可以主动向客户端推送数据，而不需要客户端先发起请求；

### 2. websocket如何实现

- 建立连接：客户端发送特殊的http握手请求来请求升级到websocket协议；服务器收到请求后，如果支持websocket，就会返回一个带有特定头部信息的http响应，表示协议升级成功；
- 通信数据帧：建立连接后，客户端和服务器之间可以相互发送数据帧（frame），数据帧是 WebSocket 通信的基本单位。数据帧可以分为文本帧和二进制帧，用于在客户端和服务器之间传输数据。
- 保持连接：WebSocket 连接是长期保持的，客户端和服务器之间可以随时发送数据，而不必重新建立连接。这种特性使得 WebSocket 适合于实时通信、在线游戏、消息推送等场景。
- 关闭连接：当通信结束或需要关闭连接时，客户端或服务器可以发送关闭帧（Close frame）来关闭连接。
- 通过 @OnOpen、@OnMessage 和 @OnClose 注解来处理连接建立、消息接收和连接关闭事件

### 3. 分布式锁、乐观锁、悲观锁

- 分布式锁：在分布式环境中，由于存在多个节点同时访问共享资源的情况，需要使用分布式锁来避免数据竞争和并发访问引起的问题。常见的实现方式包括基于数据库、ZooKeeper、Redis等工具。
- 乐观锁：认为并发访问冲突的概率较小，因此在读取数据时不加锁，在更新数据时检查数据版本或时间戳等标识，如果没有发生冲突，则顺利更新数据；如果发生冲突，则进行回滚或重试操作。乐观锁适用于读操作频繁、写操作相对较少的场景。
- 悲观锁：认为并发访问冲突的概率较大，因此在读取数据时就会加锁，以防止其他线程同时修改数据。悲观锁适用于写操作频繁、且并发访问比较密集的场景。

### 4. 分布式锁的具体实现方式

- 基于数据库：通过在数据库中创建一张表或者一条记录来表示锁状态；当一个节点需要获取锁时，会向数据库中插入一条特定的记录，其他节点在尝试获取锁时会受阻；释放锁时，节点会删除或更新数据库中的记录
- 基于缓存：使用缓存系统（如Redis）来实现分布式锁，利用缓存的原子性操作来保证锁的互斥性；当一个节点需要获取锁时，在缓存中设置一个特定的键值对，其他节点在同一时间无法设置相同的键值对；释放锁时，节点删除对应的键值对

### 5. hashmap的底层

- HashMap 的底层结构是一个数组，每个数组元素是一个链表或红黑树的头节点（称为桶）；
- 如果发生哈希冲突（不同键的哈希值映射到相同的桶位），则以链表或红黑树的形式存储在同一桶位上。
- 通过哈希函数和链表/红黑树的结构，可以在常数时间内进行快速的查找、插入和删除操作。
- HashMap 的性能受到哈希碰撞的影响，因此良好的哈希函数和合理的负载因子是保证 HashMap 性能的关键因素。

### 6. 为什么要引入红黑树 红黑树的性质 优点

- 引入红黑树主要是为了解决链表过长时导致的性能问题；
- 优点：平衡性保证了快速的查找、插入和删除；适合动态插入删除的场景；可靠的性能；

### 7. mysql锁

- 锁是用来管理并发访问数据库中数据的机制，它可以确保在多个用户同时访问和修改同一数据时，不会发生数据不一致或丢失更新的情况
- 行级锁：最小的粒度，锁定单独的行，适合高并发环境下对单独行的访问和修改
- 表级锁：锁定整个表，在写操作时会阻塞其他写操作和读操作，适用于较少并发的场景
- 页级锁：锁定数据页，介于行级锁和表级锁之间，不常用

### 8. mysql索引数据结构

- B+ 树，这是一种多路搜索树；
- 平衡性：每个叶子节点到根节点的长度相同，保证了检索的稳定性和效率
- 有序性：B+ 树的内部节点以及叶子节点都是有序的，便于范围查找
- 高扇出：每个节点存储的关键字较多，减少了树的高度，提高了查询效率
- 适合磁盘存储：B+ 树的特性使得它更适合磁盘存储，减少了磁盘 I/O 操作

### 9. B+树和红黑树的区别

- B+树适合磁盘存储，支持范围查询和排序操作；红黑树适合内存存储，适合频繁插入和删除操作。
- B+树是多路平衡查找树，数据存储在叶子节点上；红黑树是自平衡二叉查找树，节点包含数据。
- B+树的节点包含大量的关键字，适合高扇出；红黑树的节点包含数据，适合较小规模的数据集。

### 10. 创建索引需要考虑些什么

- 选择合适的列
- 避免过度索引：会占用额外的存储空间
- 考虑索引的顺序：对于涉及多个列的查询，考虑创建复合索引
- 注意数据类型：索引的数据类型应尽可能小，以减少存储空间和提高查询效率
- 定期维护索引

### 11. 如何优化索引

- 使用覆盖索引：尽量让查询能够通过索引完成，减少回表查询，提高查询效率
- 避免在索引列上使用函数：如果在索引列上使用函数操作，可能会导致无法使用索引，应尽量避免这种情况。
- 分析查询执行计划：通过分析查询执行计划，可以了解查询的性能瓶颈，有针对性地进行索引优化
- 使用索引提示：在某些情况下，数据库优化器可能无法正确选择最优的索引，可以使用索引提示来指导优化器选择合适的索引
- 监控索引的使用情况：通过数据库的性能监控工具，可以实时监控索引的使用情况和性能表现，及时调整索引策略

### 12. mysql引擎有什么

- 存储引擎（Storage Engine）是负责管理数据存储和检索的模块，它定义了数据如何存储、检索、索引和处理
- InnoDB 是 MySQL 的默认存储引擎，它支持事务、行级锁、外键约束等高级功能，适合于大多数 OLTP（联机事务处理）应用;InnoDB 支持 ACID（原子性、一致性、隔离性、持久性）特性，提供高度的数据完整性和并发控制
- MyISAM 是 MySQL 中最早的存储引擎，不支持事务和行级锁，但适合于读密集的应用;MyISAM 对于表级锁定，适用于一些非事务性的应用，例如数据仓库等
- MEMORY 存储引擎将表中的数据存储在内存中，适合于临时表、缓存等需要快速访问的场景;由于数据存储在内存中，速度很快，但在重启数据库或发生崩溃时，数据会丢失

### 13. 数据库 事务的四大特性

- ACID
- 原子性（Atomicity）：原子性指数据库事务是一个不可分割的工作单位，要么全部执行成功，要么全部失败回滚。
- 一致性（Consistency）：一致性指数据库事务将数据库从一个一致性状态转变为另一个一致性状态。
- 隔离性（Isolation）：隔离性指数据库系统在执行多个事务时，要求每个事务的操作互相独立，彼此之间不会产生影响。
- 持久性（Durability）：持久性指一旦事务提交，其所做的修改将会永久保存在数据库中，并对其他事务和外部故障具有持久影响。

### 14. 使用innodb的表数据结构存储方式

- 聚簇索引：InnoDB 表中的数据是按照主键顺序存储的，这就意味着数据实际上是按照主键顺序排列的。因此，InnoDB 表中的主键实际上是一个聚簇索引
- 辅助索引：除了主键索引外，InnoDB 表可以有多个辅助索引（即普通索引）。每个辅助索引都会包含索引字段和指向对应行的主键值，通过主键值再去找到对应的行数据。
- 数据页：InnoDB 使用固定大小的数据页（通常为 16KB）来存储数据，并且通过 B+ 树数据结构来组织这些数据页。这种方式有利于高效地进行范围查找和范围扫描操作。
- 行格式：InnoDB 表中的行数据存储格式可以是 COMPACT 或者 REDUNDANT。COMPACT 格式适用于普通的业务表，它对行数据进行了紧凑的存储和压缩；而 REDUNDANT 格式则用于历史遗留的表，它保留了更多的额外信息。
- MVCC：InnoDB 使用多版本并发控制（MVCC）来支持事务的隔离级别，这意味着每行数据都会维护多个版本，以便实现事务的并发访问。

### 15. 索引什么情况下会失效

- 使用函数或表达式进行查询
- 字段进行了隐式类型转换
- 对字段进行了 NULL 值判断
- 数据量较小的表
- 字段上存在大量重复值
- 索引未被合理利用

### 16. mysql中一条数据的查询过程

- 构建查询语句
- 发送查询请求：通过 MySQL 客户端（如命令行工具、MySQL Workbench 等）或者编程语言的数据库连接库，发送构建好的 SQL 查询语句到 MySQL 数据库服务。
- MySQL 数据库处理查询：MySQL 数据库接收到查询请求后，会解析查询语句，执行相应的查询操作
- 执行查询计划：MySQL 数据库根据查询语句中的条件和索引等信息，生成查询执行计划，决定如何最有效地执行该查询。
- 执行查询操作：MySQL 数据库按照生成的查询执行计划执行查询操作，检索满足条件的数据。
- 返回结果集：一旦查询操作完成，MySQL 数据库将查询结果作为结果集返回给发起查询请求的客户端
- 客户端处理结果：客户端接收到查询结果后，可以对结果进行进一步的处理和展示，比如在命令行工具中打印结果，或者在应用程序中进行数据处理和展示。

### 17. map和hashmap

- Map是一种用于存储键值对的数据结构，允许通过键来查找值。而HashMap是Map接口的一个具体实现类，基于哈希表实现
- Map接口表示映射表，其中的键和值都可以是任意类型;Map中的键是唯一的，每个键最多只能映射到一个值;
- HashMap是基于哈希表实现的Map接口的一个类;HashMap允许存储null键和null值;HashMap不保证键值对的顺序，即不保证遍历顺序和插入顺序一致;在大多数情况下，HashMap的插入、删除和查找操作的时间复杂度为O(1)
- hashmap相较于map的优势：快速的查找和插入操作；允许存储null键值；无序性（不保证键值对的顺序）；扩展性（拉链法解决哈希冲突）；

### 18. hashmap，链表长度大于8时，链表换成红黑树

- 当链表过长时，在查找某个键值对时可能需要遍历整个链表，导致查找效率降低。而红黑树作为一种自平衡的二叉查找树，可以保证在最坏情况下的搜索时间复杂度为O(log n)，相比链表有更快的查找速度

### 19. 说说缓存一致性，业界常用解决方案是什么

- 缓存一致性是指在分布式系统中，确保不同节点上的缓存数据与后端数据的一致性;引入缓存提高读性能，不用每次都从数据库读数据；缓存中间件：redis,性能高，提供很多友好的数据类型;
- 缓存利用率最大化：先读缓存，如果缓存不存在，则从数据库读取，并重建缓存；同时写入缓存的数据都设置失效时间，只保留“热数据”；
- 业界解决方案：强一致性：2PC、3PC、Paxos、Raft分布式一致性算法;弱一致性；最终一致性
- 缓存失效策略：通过设置合适的缓存失效策略来保证数据的及时更新。例如，可以设置缓存数据在一定时间后自动失效，或者在数据发生变化时手动将缓存标记为失效。
- 读写锁机制：在并发读写场景下，引入读写锁机制可以有效地控制对缓存数据的访问，避免脏数据的产生。
- 发布订阅模式：通过发布订阅模式，当后端数据发生变化时，及时通知各个缓存节点进行数据更新，保持数据的一致性。
- 版本号控制：每次数据更新时增加一个版本号，缓存节点在获取数据时同时获取版本号，当版本号不一致时触发数据更新。
- 缓存代理：引入缓存代理层，负责管理缓存数据和后端数据之间的同步，实现数据的一致性。
- 写后读一致性：在数据更新后，保证后续的读操作都能获取到最新的数据，可以通过延迟失效、写完后立即更新缓存等方式实现。

### 20.进程线程区别

- 进程（Process）是指计算机中正在运行的一个程序实例。例如，打开的微信就是一个进程；
- 线程（Thread）称为轻量级进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等；
- 一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈；
- 线程和进程最大的不同在于基本上各进程是独立的，而同一进程中的线程极有可能会相互影响；线程执行开销小，但不利于资源的管理和保护；而进程正相反。

### 21.进程切换开销

- 进程切换：从正在运行的进程中，收回CPU的使用权利，交给下一个要运行的进程；
- 进程切换开销大原因：保存和恢复上下文（CPU 寄存器、程序计数器、堆栈指针）、虚拟内存的切换、页表的更新（虚拟内存地址与物理内存地址之间的映射关系）、进程调度算法。

### 22.线程阻塞

- 线程阻塞是指线程暂时停止执行，等待某种条件满足或者某个事件发生后才能继续执行的状态；
- 线程阻塞原因：I/O阻塞、锁阻塞、条件变量阻塞、信号阻塞；

### 23.进程通信方法

- 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。用户空间和内核空间都属于内存。
- 管道(Pipe)：管道是一种半双工的通信方式，它通过一个文件描述符连接两个进程，一个进程通过管道的写端写入数据，另一个进程通过管道的读端读取数据。管道通常用于具有父子关系的进程之间进行通信。
- 命名管道(Named Pipe)：命名管道是一种具有名称的管道，它可以在无关的进程之间进行通信。与普通管道不同的是，命名管道在文件系统中有一个路径名，并且可以通过这个路径名进行访问。
- 信号(Signal)：信号是一种异步的通信方式，用于通知进程发生了某个事件。比如，当进程收到 SIGINT 信号时，表示用户按下了中断键(Ctrl+C)，进程可以捕获这个信号并执行相应的处理逻辑。
- 消息队列(Message Queue)：消息队列是一种在进程间传递数据的通信方式，它允许一个进程向另一个进程发送消息，并且可以实现进程间的同步和异步通信。
- 共享内存(Shared Memory)：共享内存允许多个进程访问同一块内存区域，这样它们可以直接读写共享的数据，而不需要进行复制或者通过中间介质进行通信。共享内存通常用于需要高效率的数据交换场景。
- 信号量(Semaphore)：信号量是一种用于实现进程间同步和互斥的机制，它可以用来保护共享资源的访问顺序，防止多个进程同时访问共享资源导致的数据不一致问题。
- 套接字(Socket)：套接字是一种在网络上进行进程间通信的通用方式，它可以在同一台主机上的不同进程之间通信，也可以在不同主机上的进程之间通信。套接字通常用于实现客户端-服务器模式的网络通信。

### 24.GET和POST请求区别

***GET 请求：*** 

- 通过 URL 向服务器传递参数，参数会以键值对的形式附加在 URL 的末尾，例如：http://example.com/path?param1=value1&param2=value2。
- 请求参数有长度限制，受浏览器和服务器限制，通常在 2KB 到 8KB 之间，因此 GET 请求适合传输较少量的数据。
- GET 请求会将请求参数显示在浏览器地址栏中，因此不适合传输敏感信息，如密码等。
- GET 请求可被缓存，可被书签收藏，可被历史记录保留，以及可被浏览器记录，因此不适合用于传输敏感信息。

***POST 请求：***

- 通过 HTTP 请求的 body 传递参数，参数不会显示在 URL 中，而是隐式地通过 HTTP 报文体传递。
- 请求参数的长度理论上没有限制，但受服务器配置的限制，通常可以传输更大量的数据。
- POST 请求适合传输较多量的数据，因此常用于提交表单、上传文件等操作。
- POST 请求对请求参数的格式没有限制，可以传输二进制数据，而 GET 请求的参数则通常是 URL 编码的文本。
- POST 请求不会被缓存，不会被书签收藏，不会被历史记录保留，以及不会被浏览器记录，因此更适合用于传输敏感信息。

### 25.JAVA EE技术

- JavaEE 号称有十三种核心技术。它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。

### 26.多线程/并发

### 27.SSM框架 Spring+SpringMVC+MyBatis

### 28.Spring和SpringBoot

***Spring***

- 配置繁琐；依赖繁琐

***SpringBoot***

- SpringBoot一个简化Spring应用开发的框架；
- 约定优于配置；
- 自动配置；起步依赖，是一个Maven项目对象模型POM；辅助功能，如嵌入式服务器；
- SpringBoot继承父工程；
- 引导类，SpringBoot项目的入口；
- 启动依赖：spring-boot-starter-parent（组合了一套最优的技术版本） spring-boot-starter-web(依赖传递)
- IOC容器负责创建、初始化、配置和销毁对象Bean；
- @Conditional根据特定条件来决定是否创建一个bean；
- spring boot内置四种web服务器，导入不同依赖坐标实现默认web服务器（tomcat）的切换；
- @Enable用于启用特定功能或配置的元注解；
- spring boot不能获取第三方jar包中的Bean，@import（四种用法）导入的类会被加载到IOC容器中；
- @EnableAutoConfiguration，约定大于配置，通过分析项目的依赖关系和当前运行环境，自动配置应用程序所需要的各种组件、框架和功能。首先，扫描classpath上的依赖；其次，使用条件化配置conditional确定需要应用的配置；然后，自动配置；最后，启动器？
- SpringBoot自带监控功能actuator(http请求返回json数据)、Admin图形界面（需要在client中指定Server地址）;
-

### 29.SpringBoot配置文件

- 两种方式，application.properties、yml、yaml（优先级依次降低，双引号识别转义字符、单引号忽略转义字符）；
- 读取配置内容：@Value、Environment、@ConfigurationProperties；
- profile激活配置文件；

### 30.消息队列在微服务中的应用

- 作为中介实现了服务间的异步通信，降低了服务间的耦合度，使得服务可以更加独立地升级和扩展；
- 通过队列暂存消息，消息队列能够实现流量削峰，提高系统的稳定性；
- 消息队列还支持动态扩展服务实例，提高了系统的处理能力；

### 31.RabbitMQ 与 Kafka

- 消息队列系统
- RabbitMQ：适用于实时性要求较高、消息量较小的场景。例如，订单处理、日志收集等。RabbitMQ的优点在于配置简单、易于管理；但在处理大量数据时，性能可能会受到限制。
- Kafka：适用于大数据量、高吞吐量的场景。如日志分析、实时数据监控等。Kafka的优点在于高性能、高可靠性；但配置相对复杂，学习成本较高。

### 32.web实时消息推送

- 短轮询，指定时间间隔，由浏览器向服务器发送HTTP请求，服务器实时返回数据给客户端；（JS定时器可以实现）；频繁的网络请求、服务器负载高、延迟、实时性差；
- 长轮询，客户端向服务器发送请求，服务器保持连接打开，当有新数据时立即响应，或在一定时间内无数据时才响应，减少不必要的网络开销，提高实时性和效率，但连接保持会占用服务器资源和连接数；
- 服务器发送事件（SSE），服务端向客户端单向消息推送（ChatGPT，在计算过程中持续返回数据，避免等待时间过长而选择关闭页面），基于HTTP协议（服务端无法主动向客户端推送消息）；开发成本低、支持断线重连、单向通信；实现方式：前端进行HTTP请求、建立连接、监听服务端推送，后端创建连接、给指定用户发送消息；
- Websocket，在TCP连接上的全双工通信协议，客户端和服务端仅需一次握手，两者就可以创建持久性的连接；工作过程：客户端发送HTTP请求，请求头包含upgrade：Websocket和sec-websocket-key字段，表示升级协议；服务器接收请求并回复HTTP101状态码，响应头包含connection：upgrade和sec-websocket-accept字段；客户端和服务端建立Websocket连接，数据以帧形式传送，每条消息会被切分成多个数据帧，接收端重组成完整的消息；客户端或服务端可以主动发送关闭帧，表示断开连接，另一方收到后也会回复一个关闭帧，然后关闭TCP连接。

### 33.TCP三次和四次握手

***TCP建立连接***

- 一次握手：客户端发送SYN（SEQ=x）标志的数据包给服务端，然后客户端SYN_SEND等待服务器的确认；服务端确认客户端发送正常，自己接收正常；
- 二次握手：服务端发送带有SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包给客户端，然后服务端进入SYN_RECV状态；客户端确认自己发送接收正常，对方发送接收正常；服务端确认对方发送正常，自己接收正常；
- 三次握手：客户端发送ACK(ACK=y+1) 标志的数据包给服务端，然后客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。客户端确认自己发送接收正常，对方发送接收正常；服务端确认自己发送接收正常，对方发送接收正常；
- 三次握手的目的是建立可靠的通信信道，确认双方的发送与接收是正常的。

***第二次握手为什么要传回SYN***

- ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，回传 SYN 则是为了建立并确认从服务端到客户端的通信；
- 为了建立可开的TCP连接；

***断开连接***

- 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 FIN-WAIT-1 状态。
- 第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。
- 只要四次挥手没有结束，客户端和服务端就可以继续传输数据！

***为什么要四次挥手？***

- TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

***为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？***

- 因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

***如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？***

- 客户端没有收到 ACK 确认，会重新发送 FIN 请求。

***为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？***

- 第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

### 33.java反射机制

- Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
- Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。
- 注解的实现也用到了反射机制；

### 34.Docker

- 一种实现容器技术的工具；
- 可以打包一个应用及依赖包到一个轻量级、可移植的容器中；
- 为了解决单机部署应用和虚拟化的局限性而诞生；
- 资源占用少、启动快；

***容器***

- 容器镜像是轻量的、可执行的独立软件包，包含软件运行所需要的所有内容：代码、运行时环境、系统工具、系统库和设置；
- 容器化软件在任何环境（Linux、Windows）中都能够始终如一地运行；容器赋予了软件独立性，减少了相同基础设施上运行不同软件时的冲突；
- 不同容器之间是相互隔离，独立运行的；
- 通常一个容器就是一个应用或服务（微服务）；

***容器状态***

- 运行、退出、暂停、健康、非健康；

***镜像***

- 镜像是创建容器的模板；
- 同一个模板可以创建多个不同的容器；
- 容器是镜像生成的运行实例；
- 仓库存放镜像，主机通过仓库下载镜像，通过镜像创建容器；

***常用命令***

- docker import 加载镜像
- docker tag 修改镜像的完整标识符（名称：版本）
- docker run -it 创建容器并运行，(-it参数)进入bash可交互终端中
- docker images 列出当前系统所有镜像
- docker ps -a 列出所有docker容器
- docker exec 进入容器内部
- docker inspect 查看镜像信息（端口映射）
- docker cp 实现主机和容器内部文件的拷贝；通过dockerjava依赖包可以实现java和容器的交互；

***容器随着docker启动而启动？修改端口映射？***

- --restart=always
- -p指定端口映射


***虚拟化***

- 资源占用多，每个虚拟机都是完整的操作系统，需要分配大量的系统资源；
- 冗余步骤多；
- 启动慢；

### 35.Nginx

- HTTP/HTTPS反向代理、负载均衡、静态站点、文件服务器
- 特点：高性能、高并发处理、低内存消耗、事件驱动架构、模块化设计以及良好的可靠性和稳定性；
- web服务器：nginx（主流）、apache

***nginx如何实现反向代理***

- 反向代理：以代理服务器来接收Internet的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外相当于反向代理服务器；
- 实现步骤：配置监听端口，用于接收客户端的请求；指定一个或多个后端服务器，这些服务器实际处理客户端的请求；设置代理规则（HTTP头部请求、SSL终止、静态资源、负载均衡、限制请求、Websocket支持），告诉nginx如何将请求转发给后端服务器；

***负载均衡***

- 网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流；
- nginx配置文件中定义了upstream块，列出所有的后端服务器；选择负载均衡方法；在Server模块中使用proxy_pass将请求转发到定义的upstream组；配置额外的代理设置；
- 负载均衡策略：轮询、加权轮询、最少连接(将请求分配给连接数最少得服务器)、加权最少连接、IP Hash（根据IP地址进行哈希，确保同一IP的请求总是发送到同一个服务器）、普通 Hash（根据请求的URI进行哈希，以平衡请求分布）

***网站有多个webapp的配置***

- 问题描述：网站有多个webapp，分别绑定不同的端口号；
- nginx可以根据请求的URL将请求转发到不同的后端应用程序；

***静态站点***

- 仅由HTML、CSS、JavaScript文件组成，以及可能的图像和其他媒体文件，不涉及服务器端的数据库交互和动态内容处理；
- 配置静态站点（html文件和一堆静态资源）

```java
location / {
			root /app/dist;
			index index.html;
			#转发任何请求到 index.html
		}
```

***文件服务器***

- 归档一些数据或资料，使用nginx可以快速搭建简易的文件服务；

```java
autoindex on;# 显示目录
autoindex_exact_size on;# 显示文件大小
autoindex_localtime on;# 显示文件时间

server {
    charset      utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解
    listen       9050 default_server;
    listen       [::]:9050 default_server;
    server_name  _;
    root         /share/fs; #会从root目录开始查找请求的资源
}
```

***解决跨域***

- 前后端分析，独立的web app互相访问，存在跨域问题；
- CORS，在后端服务器设置HTTP响应头，把你需要允许访问的域名加入Access-Control-Allow-Origin中
- jsonp，把后端根据请求，构造 json 数据，并返回，前端用 jsonp 跨域。
- nginx，首先在 enable-cors.conf 文件中设置 cors，然后在你的服务器中 include enable-cors.conf 来引入跨域配置；




### 36.HTTP和HTTPS的区别

***http***

- hyper text transfer protocol超文本传输协议，超文本指的是包括文本在内的各式各样的消息；
- http应用层协议，以TCP（输出层）作为底层协议，默认端口80；
- 优点：扩展性强、速度快、跨平台支持性好；缺点：安全性低；

***https***

- hyper text transfer protocol secure，基于http和tcp，并额外使用SSL/TLS协议用作加密和安全认证，默认端口443；
- SSL通道常使用基于秘钥的加密算法，密钥长度通常40比特和128比特；
- 优点：保密性好、信任度高；缺点：消耗更多服务器资源；

***SSL***

- Secure Sockets Layer安全套接字协议，TLS基于SSL；
- 非对称加密，采用两个密钥，公钥和私钥；利用公钥加密，利用私钥解密；公私钥的生成算法依赖于单向陷门函数；计算代价较高，效率太低；
- 对称加密，通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性；
- 通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。

### 37.http状态码

- http状态码用于描述http请求结果
- 1XX：信息性状态码，接收的请求正在处理，平时不会碰到；
- 2XX：成功状态码，请求正常处理完毕；
  - 200 OK：请求被成功处理，例如查询用户信息；
  - 201 Created：请求被成功处理，例如创建新用户；
  - 202 Accepted：服务端接收到了请求，但还未处理；
  - 204 No Content：成功处理请求，但没有返回任何内容；
- 3XX：重定向状态码，需要进行附加操作以完成请求；
  - 301 永久重定向，例如网址更换；
  - 302 临时重定向，例如网站资源暂时转移到另一网址；
- 4XX：客户端错误状态码，服务器无法处理请求；
  - 400 bad request：发送的http请求存在问题，例如参数不合法，请求方法错误；
  - 401 unauthorized：未认证却请求需要认证后才能访问的资源；
  - 403 forbidden：拒绝http请求，一般针对非法请求；
  - 404 not found：请求资源未在服务端找到，比如请求某个用户的信息，服务端没有找到；
  - 409 conflict：请求的资源与服务端当前的状态存在冲突；
- 5XX：服务器错误状态码，服务器处理请求出错；
  - 500 internal Server error：服务端出问题了，例如服务端处理请求时突然抛出异常，但异常在服务端未被正确处理；
  - 502 bad gateway：网关将请求转发到服务端，但服务端返回的是一个错误的响应；

### 38.什么是redis

- 基于c语言开发的开源NoSQL数据库。数据保存在内存中，支持持久化，因此读写速度快，被广泛应用于分布式缓存方向。并且存储的是KV键值对数据。
- 应用广泛：缓存、分布式锁、限流、消息队列、延时队列；

***redis和关系型数据库的区别***

- redis存储键值对数据；关系型数据库存储结构化数据（表格形式）；
- redis数据存储在内存，读写速度快；关系型数据库数据存储在硬盘上，可以通过索引和优化来提升性能；
- redis提供了数据持久化选项，可以将内存中的数据定期或按需写入磁盘；关系型数据库数据本身就存储在磁盘上；
- redis支持简单的事务，不支持多行事务或复杂的事务空间；关系型数据库提供强大的事务支持，包括ACID（原子性、一致性、隔离性、持久性）；（事务指的是操作各种数据项的一个数据库操作序列）；
- redis查询功能相对简单，主要通过键来访问数据；关系型数据库提供丰富的SQL查询语句，支持复杂的数据查询、连接、聚合和子查询等操作；
- redis在单线程模型下运行，保证了操作的原子性，在分布式环境中需要额外的机制来保证数据一致性；关系型数据库通过锁和事务机制来保证数据的一致性和隔离性；
- redis适合用作缓存、会话存储、排行榜、实时分析、消息队列等场景；关系型数据库适合需要复杂查询、事务处理、数据完整性保证的应用程序，如金融系统、企业资源规划（ERP）等；

***redis为什么快***

- 基于内存；
- 基于 Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路复用；
- 内置了多种优化过后的数据类型/结构实现，性能非常高；
- 通信协议实现简单且解析高效；

***分布式系统***

- 由多个计算机节点通过网络连接而成的系统，这些节点可以是物理上分散在不同地理位置的计算机，也可以是虚拟机或容器。

***缓存***

- 用redis实现缓存；
- 缓存用于提高数据访问速度，减少延迟，并通过减少对主存储或数据库的访问次数来提高系统性能。缓存的工作原理是将频繁访问的数据存储在快速、低成本的存储介质中，以便快速检索。
- 把数据库中的部分数据转移到缓存中，这样用户的部分请求直接到缓存不用经过数据库，从而提高系统整体的开发；

***缓存读写策略***

- 旁路缓存模式：
  - 写：先更新db；然后直接删cache；
  - 读：从cache中读取数据，读取到就直接返回；cache中读取不到，就从db中读取数据返回；再把数据放到cache中；
- 读写穿透：
  - 写：先查 cache，cache 中不存在，直接更新 db；cache 中存在，则先更新 cache，然后 cache 服务自己更新 db；
  - 读：从 cache 中读取数据，读取到就直接返回；读取不到的话，先从 db 加载，写入到 cache 后返回响应；
- 异步缓存写入：
  - 适合对数据一致性没那么高的场景；

***redis实现分布式锁***

- 分布式锁用于协调多个进程或线程访问共享资源；分布式锁确保同一时间只有一个进程可以执行特定的操作或访问特定的资源；
- 分布式锁的核心在于互斥；
- 通过SETNX命令加锁；基于Lua脚本释放锁（Lua脚本保证了解释操作的原子性）；为了避免锁无法被释放，需要设置过期时间；操作共享资源的操作未完成，锁过期时间需要续期（解决方案：Redisson）；
- Redisson中的分布式锁自带自动续期机制

***redis如何实现持久化***

- 持久化：数据在系统断电或崩溃后依然能够保持并再次使用的能力，数据被存储在某种非易失性存储介质；Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；
- RDB 持久化：RDB 是将 Redis 在内存中的数据以快照的形式保存到磁盘上的一种持久化方式。当启用 RDB 持久化时，Redis 会根据配置的策略定期将数据保存到磁盘上的一个文件中。RDB 文件是一个二进制文件，包含了 Redis 在某个时间点上的数据快照。RDB 持久化适用于备份和恢复数据，以及在数据量较大时，通过定期生成快照文件可以减少恢复时的数据恢复时间。
- AOF 持久化：AOF 是将 Redis 的写操作以追加的方式记录到一个文件中的一种持久化方式。当启用 AOF 持久化时，Redis 会将每个写操作记录到 AOF 文件的末尾。这样做的好处是可以确保每个写操作都被持久化，从而最大程度地避免数据丢失。

***redis实现延时任务***

- redisson内置的延时队列，redisson是基于java的redis客户端库，与redis是客户端和服务器的关系；减少了丢消息的可能、消息不存在重复消费问题；

***redis数据类型***

- 5 种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）
- 3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)

***微服务***

- 将大型复杂软件应用分解为一系列小型、松散耦合、功能独立的服务。每个微服务围绕特性的业务功能构建，拥有自己的数据库、代码库和运行环境，通过轻量级的通信机制（HTTP RESTful API）与其他服务交互；
- 单一职责原则（高内聚低耦合）；独立部署；技术多样性；业务驱动；去中心化治理；敏捷性；容错性；可维护性；可测试性；服务发现；Api网管；持续集成和持续部署；

### 39.Knife4j

***简介***

- Knife4j 是一个为 Java MVC 框架集成 Swagger 生成 Api 文档的增强解决方案，其前身是 swagger-bootstrap-ui。

***核心功能***

- 文档说明：接口地址、类型、请求示例、参数、响应示例、参数、响应码等信息；
- 在线调试；
- 参数校验；
- 兼容性；
- 界面友好；

***使用步骤***

- 引入依赖；
- 配置Swagger注解；
- 启动项目/doc.html路劲访问；
- 查看和测试接口；

### 40.Threejs

- Three.js是一个基于JavaScript的开源3D图形库，用于创建和显示各种3D场景和动画。它建立在WebGL之上，简化了在网页上使用3D图形技术的复杂性，使开发者能够轻松地在浏览器中创建交互式的3D内容。
- 使用步骤：创建三维空间场景；创建相机（观察点、观察方向、角度）；创建渲染器；创建物体、光源，并添加到场景中；通过渲染器将场景、相机渲染到页面上；

### 41.聚簇索引与非聚簇索引

- 索引是一种提高数据检索速度的数据结构；类似于书籍的目录，允许快速定位到特定的数据记录，而不需要逐行读取数据表中的每个记录。

***聚簇索引***

- 聚簇索引即索引结构和数据一起存放的索引，例如主键索引。在MySQL中，InnoDB引擎的表的.ibd文件就包含了该表的索引和数据，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
- ibd文件就包含了该表的索引和数据；
- 优点：查询速度快、对排序查找和范围查找优化；
- 缺点：依赖于有序的数据、更新代价大（因此书剑一般不可被修改）；

***非聚簇索引***

- 索引结构和数据分开存放的索引，并不是一种单独的索引类型，例如二级索引（辅助索引）；MySQL的MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。
- .MYD文件包含表的数据、.MYI文件包含表的索引；
- 优点：更新代价比聚簇索引小；
- 缺点：依赖于有序的数据、可能会二次查询（回表，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询）；

### 42.B+树

- 全称多路平衡查找树，大部分数据库系统及文件系统都采用B或B+树作为索引结构；

***B树***

- B树的所有节点既存放key也存放data;
- 叶子结点独立；
- 检索过程相当于二分查找，没到达叶子节点，检索就结束了；
- 范围查询时，需要先找到下限，后中序遍历，找到上限；

***B+树***

- 只有叶子节点存放key和data，其它节点只存放key;
- 叶子节点有一条引用链指向与它相邻的叶子节点；
- 检索效率稳定，任何查找都需要从根节点到叶子节点；
- 对链表进行遍历即可；
- 相比于B树，具备更少的IO次数（查找数据所需的树高较小）、更稳定的查询效率和更适合于范围查询；

### 43.JVM垃圾回收

- Java自动内存管理核心的功能是堆内存中对象的回收和分配；
- 对象创建：堆内存被分为三个部分：新生代内存（Eden、s0、s1，大多数新创建的对象被分配在这里）、老生代（Tenured，当对象在新生代经历一定数量的垃圾回收后仍然存活，它们将会被晋升到老年代）、永久代(MetaSpace，用于存放类信息、常量池)；
- 垃圾识别：JVM通过跟踪对象的引用情况来识别垃圾。只要对象能够通过一系列名为“GC Roots”的根对象被引用，它就被认为是活跃的。GC Roots通常包括线程的局部变量、静态变量、全局变量等；
- 垃圾回收算法：
  - 标记-清除（Mark-Sweep）：首先通过可达性标记垃圾，然后遍历整个堆内存将没有标记的对象进行回收。
  - 复制（Copying）：将内存分为两个区域（from区 to区），垃圾回收过程中，将所有存活的对象从一个区域复制到另一个区域，然后清理原区域中的所有对象。避免了内存碎片化，但是需要额外的内存空间用于复制对象。
  - 标记-压缩（Mark-Compact）：结合了标记-清除和复制算法的优点。先标记需要回收的对象，然后将存活的对象向堆的一端移动以压缩内存，最后清理堆末端的所有无效对象，以减少内存碎片。
  - 分代收集（Generational Collection）：基于对象生命周期的不同，将堆分为新生代和老年代，分别采用不同的策略进行垃圾回收。新生代中的对象存活率较低，适合使用复制算法（效率较高的垃圾回收算法）；老年代中的对象存活率较高，适合使用标记-压缩算法（保守的垃圾回收算法）。
- 垃圾回收触发：大多数情况下，对象在新生代中Eden区分配；当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC；当老年代空间不足时会触发Full GC;
- 垃圾回收器：JVM提供了多种垃圾回收器，如Serial、ParNew、CMS、G1等，它们采用不同的策略和算法来优化垃圾回收的性能和延迟；

### JVM内存空间

- JVM启动时创建内存空间，内存空间包含方法区（永久代被元空间取代）、栈内存、本地方法栈、程序计数器（用于存储当前线程正在执行的字节码指令的地址）；
- 垃圾收集器（garbage collector，GC）实现垃圾识别和回收；垃圾识别方式：引用次数法（根据每个对象被引用的次数确定对象是否可以被回收）、可达性分析（从一组称为"GC ROOTS"对象开始遍历对象之间的引用关系，识别出活跃对象，那些无法通过任何路径与"GC ROOTS"相连的对象被认为是不可达的，即垃圾对象）；
- Minor GC主要针对堆内存中的新生代区域，使用执行效率较高的垃圾回收算法，例如复制算法。Full GC针对老年代区域，对整个堆空间进行垃圾回收，使用保守的垃圾回收算法。


### 44.数据库引擎InnoDB、MyISAM

- 存储引擎是数据库的核心组件，决定了数据的存储方法、索引方式以及数据的读写操作；
- MyISAM是MySQL5.5之前默认存储引擎
  - 不支持事务，但操作具有原子性
  - 使用表级锁，适合读取密集型的应用
  - 支持全文索引
  - 索引和数据文件是分开的，索引文件包含数据文件的指针
  - 适合于不需要事务支持的场合，如博客系统或静态网页存储
- InnoDB是MySQL5.5之后的默认存储引擎
  - 支持事务处理，具有提交、回滚和崩溃恢复能力
  - 默认的存储引擎，从MySQL 5.5.5开始
  - 支持外键约束
  - 使用行级锁和MVCC（多版本并发控制），适合高并发环境
  - 支持聚集索引，数据文件和索引文件存放在一起

### 45.插入排序、选择排序、快速排序、堆排序

- 插入排序：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直到整个序列有序为止；
- 选择排序（最大最小值排序）：每一次从待排序的数据元素中选出最小或最大的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完；
- 快速排序：从数列中取出一个数作为基准数，分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边，再对左右区间重复第二步，直到各区间只有一个数；
- 堆排序：可以利用数组的特点快速定位指定索引的元素，适合处理大量数据的排序问题；
- 冒泡排序：通过重复遍历要排序的数列，比较每对相邻元素，如果它们顺序错误就把它们交换过来。重复过程直到没有需要交换的元素为止。

### 46.动态规划DP

- 通常用于解决具有重叠子问题和最优子结构性质的问题

### 47.全双工、半双工、单工

- 全双工：可以同时进行双向数据传输；
- 半双工：允许信号在两个方向上传输，但某一时刻只允许信号在一个信道上单向传输；
- 单工：只支持在一个方向上传输；
