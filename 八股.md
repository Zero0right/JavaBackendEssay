# 大厂 java后端开发 数据分析 前端开发 

## java基础

### 1. java的特点

- 平台独立性和移植性：归根于Java虚拟机JVM。已编译的Java程序，class文件（字节码）可以在带有JVM的平台上运行。
- 稳健性：强类型语言，扩展编译时检查类型不匹配问题；显示声明，要求严格能捕捉调用错误；try/catch/finally异常处理；

### 2. java和cpp的区别

- java纯粹面向对象；cpp兼容c，面向对象也面向过程；
- java通过JVM可以跨平台；cpp依赖于特定的平台；
- java没有指针，引用可以理解为安全的指针；
- java支持自动垃圾回收；cpp需要手动回收；
- java不支持多重继承，但能实现多个接口；cpp支持多重继承；

### 3. JDK/JRE/JVM三者的关系

- JDK：java开发工具包；集成了JRE+java工具+编译器+调试器；
- JRE：java运行时环境；包含JVM和java核心类库；可用于运行java程序，不能用于开发java程序，是运行Java应用程序的完整环境；
- JVM：java虚拟机，是一个在实际计算机硬件和操作系统之上的虚拟计算机，负责执行java字节码；字节码执行、内存管理（垃圾回收）、安全管理、跨平台性、性能优化；

### 4. java程序是编译执行还是解释执行

- 编译型：通过编译器将源程序翻译成机器码；总结：执行速度快、效率高、依靠编译器、跨平台性差；c cpp pascal object-c swift；
- 解释性：翻译成中间代码，再由解释器对中间代码进行解释运行，运行时翻译成机器码；总结：执行速度慢、效率低、依靠解释器、跨平台性好；JavaScript Python erlang php perl ruby
- java源代码先通过javac编译成字节码，在通过jvm将字节码转成机器码；半编译半解释；

### 5. 面向对象和面向过程的区别

- 面向过程：分析解决问题的步骤，用函数将步骤实现，依次调用函数；
- 面向对象：将问题分解成各个对象，分别设计对象，组装成有完整功能的系统；用类实现各个功能模块；

### 6. 面向对象有哪些特性

- 封装、继承、多态、抽象
- 封装：类的方法才能对属性进行操作和访问，减少耦合；
- 继承：子类继承父类的属性和方法，并可以有新的属性和方法；java单继承；增加重用性和易维护性；
- 多态：同一个行为具有多个不同表现形式的能力；实现多态的三要素：继承、重写、父类引用指向子类对象；
  *静态多态性：* 重载实现，相同方法具有不同的参数，做出不同的处理；
  *动态多态性：* 子类中重写父类的方法；
- 抽象：抽象类和抽象方法，只包含方法声明没有具体实现；抽象类不能被实例化；

### 7. java中的基本数据类型

- byte: 8bit 
- char:16bit 
- short:16bit 
- int:32bit 
- float:32bit 
- long:64bit 
- double:64bit 
- boolean

### 8. 为什么不能用浮点型表示金额

- 浮点数：计算机保存的小数是十进制小数的近似值，不是精确值；
- 建议用BigDecimal或者Long表示金额

### 9. 什么是包装类型，为什么需要包装类型

- 包装类型：让基本数据类型有了对象的性质，添加了属性和方法；
- 为什么需要：很多地方需要使用对象而不是基本数据类型，比如集合类中，无法将基本数据int、double等类型放进去，集合容器要求元素是Object类型；

### 10. 装箱和拆箱

- 装箱：将基本类型转化为包装类型
- 插箱：将包装类型转化为基础类型

### 11. String为什么不可变

- 安全：不可变的字符串更安全，可以被自由地共享，而不需要担心被修改，对于多线程环境尤为重要因为消除了同步的需求；
- 性能：字符串常量池的实现依赖于String的不可变性，如果可变，字符串常量池中的String可能会被意外修改，导致潜在的错误和内存泄漏；
- 缓存hash值：由于String不可变，它们的哈希码可以被缓存，使得String键的散列查找更快；

### 12. String Stringbuffer Stringbuilder区别

- String不可变，线程安全；
- StringBuffer 是线程安全的，内部使用 synchronized 进行同步（同步带来开销）；
- 对于大多数单线程应用程序，Stringbuilder是首选，具有更好的性能，非线程安全。

### 13. String类的常用方法有哪些

- indexOf() 返回指定字符的索引
- charAt() 返回指定索引处的字符
- replace() 字符串替换
- trim() 去除字符串两段空白
- split() 分割字符串，返回一个分割后的字符串数组
- getBytes() 返回字符串的byte类型数组
- length() 返回字符串长度
- toLowerCase() 将字符串转成小写字母
- toUpperCase() 将字符串转成大写字符
- substring() 截取字符串
- equals() 字符串比较

### 14. 什么是StringJoiner

- java8引入 用于拼接字符串的工具类；
- 自定义分隔符 前缀 后缀
- StringJoiner sj = new StringJoiner(", ", "[", "]");
  sj.add("Apple");
  sj.add("Banana");
  sj.add("Orange");
  String result = sj.toString();
  System.out.println(result); // 输出：[Apple, Banana, Orange]。

### 15. new String("xxx")会创建几个对象

- 两个；字符串常量池中创建一个字符串对象，指向xxx；
- new关键字会在堆内存中再创建一个新的字符串对象；
- 字符串常量池在堆内存的永久代（元空间）中；

### 16. 什么是字符串常量池

- String pool保存着所有字符串字面量，这些字面量在编译时期就确定；
- 位于堆内存中；
- 创建字符串时，JVM检查String pool，如果已在池中，则返回其引用，若不存在，则创建并放入池中，并返回其引用；

### 17. String最大长度是多少

- 受length方法限制，其返回值为int类型，取值上限为2^31-1;
- 最大长度的字符串需要4GB的内存空间;
- 字符串声明+编译后 会以常量的形式进入常量池；
- 字符串常量长度不超过65534；堆内字符串的长度不超过2^31-1;

### 18. Object常见方法

- toString() 返回对象的字符串表示；
- equals(object obj) 比较两个引用变量是否指向同一个对象（内存地址）；
- hashCode 将与对象相关的信息映射成一个哈希值，默认hashcode根据内存地址换算出来；
- clone 实现对象中各个属性的复制，但可见范围是protected；
- getClass 返回对象的运行时类
- notify 唤醒在该对象上等待的单个线程
- notifyAll 唤醒在该对象上等待的所有线程
- wait 导致当前线程等待；

### 访问修饰符

| 修饰符 | 当前类 | 同包 | 子类 | 其他包 |
| :-: |:-: |:-: |:-: |:-: |
| private | √ | × | × | × |
| default | √ | √ | × | × |
| protected | √ | √ | √ | × |
| public | √ | √ | √ | √ |

### 19. 浅拷贝和深拷贝

- 浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象
- 深拷贝：拷贝对象和原始对象的引用类型引用不同的对象

### 20. 两个对象的hashCode相同，equals是否一定为true

- Object类的equals方法，默认情况下，比较的是对象的引用是否相同，即检查两个对象是否指向内存中的同一个位置；
- hashcode相同，equals不一定相同
- equals返回true,那么hashCode一定相同
- hashcode主要用来高效管理对象并在集合中进行快速查找和存储

### 21. Java创建对象有几种方式

- new语句创建对象
- 使用反射，Class.newInstance()创建对象
- 调用对象的clone()方法
- 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法

### 22. 类实例化的顺序

- 静态属性初始化（static，关键字，类级别）
- 静态代码块初始化
- 普通属性初始化
- 普通代码块初始化
- 构造方法初始化

### 23. equals和==的区别

- 对于基本数据类型 ==比较值 没有equal方法；
- 对于复合数据类型 ==比较的是存放地址;equals默认的行为是使用==比较对象的引用地址；在许多Java类中，equals方法被重写以比较对象的内容而不是引用地址；

### 24. 常见的关键字

- static 修饰类的成员方法和变量;静态变量和方法，可以直接通过类名访问；
- final 修饰类则不能被继承；修饰方法则不能被子类重写；修饰变量则只能赋值一次；
- this 是一个引用，指向当前对象的实例，可以用来区分实例变量和局部变量；
- super 是一个引用，指向父类的实例

### 25. final finally finalize的区别

- final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承
- finally异常处理语句结构的一部分try-catch-finally，表示代码块总是被执行
- finalizeobject类的方法，一般由垃圾回收器调用

### 26. 方法重载和重写的区别

- 重载：在同一个类中，可以有多个同名的方法，主要它们的参数列表不同（参数数量、类型或顺序不同）；目的：提供方法的多种形式，使得同一个操作可以适用于不同的参数类型或数量；
- 重写：子类对父类的方法进行重写@Override，即子类可以提供一个特定的实现来替换父类的实现，要求方法名、返回类型和参数列表完全一致；目的：实现多态性，允许子类根据需求改变父类的行为；

### 27. 接口与抽象类的区别

- 接口完全抽象，只包含方法的声明和常量的定义，一个类可以实现一个或多个接口；抽象类，包含抽象方法（没有实现的方法）和具体方法（有实现的方法），一个类只能继承一个抽象类；
- 接口不能直接被实例化，必须通过实现接口的类来实现；抽象类不能直接实例化；
- 一个类可以实现implements多个接口，必须实现接口中声明的所有方法；一个类接口只能继承extend一个抽象类，子类可以选择性实现或覆盖抽象方法；
- 接口没有构造函数；抽象类可以有构造函数；
- 接口中的所有方法默认都是public的，不能有访问修饰符；抽象类可以包含不同访问级别的方法和成员变量；
- 接口只能定义常量，public static final；抽象类可以定义各种类型的字段，实例变量、静态变量；

### 28. 常见的Exception有哪些

*runtimeException*
- 类型转换异常
- 数组越界异常
- 空指针
- 数组存储异常
- 数字格式化异常
- 数学运算异常
*checked exception*
- 反射异常，没有对应的字段
- 类没有找到异常
- 安全权限异常

### 29. error和exception有什么区别

- error JVM无法解决的问题，如何栈溢出、内存溢出等。程序无法处理的错误；
- exception 编程错误或外在因素导致的一般性问题，可以在代码中处理，如空指针异常、数组下标越界；

### 30. 运行时异常和非运行时异常区别

- runtimeException 程序错误导致，应该修正程序避免这类异常发生
- checked exception 由具体的环境导致的异常，读取的文件不存在或文件为空或sql异常。

### 31. throw和throws的区别

- throw 在代码块中手动抛出一个异常对象
- throws 声明方法中可能会抛出的异常

### 32. BIO/NIO/AIO

- 阻塞BIO：每次来一个请求，就分配到线程池中由一个线程处理，如果超过线程池的最大上限，就扔到队列等待；I/O操作是阻塞的；高并发情况下性能较差；
- 非阻塞NIO：引入了通道和缓冲区，非阻塞处理I/O操作；通过selector，一个线程可以管理多个通道的I/O操作，高并发下性能较好；
- 异步非阻塞AIO：不需要线程阻塞等待I/O完成；适用于处理大量并发；相比于NIO，更适合处理文件和网络I/O；

### 33. 守护线程是什么

- 守护线程是运行在后台的一种特殊进程；
- 独立于控制终端并且周期性执行某种任务或等待处理某些发生的事件；
- 在Java中垃圾回收线程就是特殊的守护线程；例如日志记录、定期清理任务；

### 34. 前台线程和后台线程

- 前台线程是程序中明确创建的线程，阻止程序终止，执行重要任务与用户交互；
- 后台线程在程序运行时在后台默默执行，不阻止程序终止，通常执行一些不需要组织程序终止的任务；

### 35. 应用程序 进程 线程

- 一个应用程序可以对应一个或多个进程，每个进程包含了应用程序的一个实例或部分；
- 一个进程可以包含一个或多个线程，线程共享进程的资源，可以并发执行不同的任务；
- 应用程序通过进程启动并运行，进程内部的线程负责实际的任务执行；
- 进程/线程生命周期：创建、就绪、运行、阻塞、结束；

### 36. java为什么不支持多继承

- java类不支持多继承；类可以通过实现多个接口；
*java不支持多继承原因*
- 如果子类继承多个父类中含有相同的方法或属性，子类不知道具体继承哪个；

### 37. java中实现对象的克隆

- 通过实现cloneable接口并重写clone方法实现浅拷贝；
- 通过序列化和反序列化实现深拷贝；

### 38. 同步和异步的区别

- 同步：阻塞式，调用者发起请求后等待才做完成并返回结果，期间无法进行其它操作；
- 异步：非阻塞，调用者发起一个请求后不需要等待操作完成，而是可以继续执行后续操作；通过回调、轮询或时间触发实现异步；非阻塞：该调用不会阻塞当前线程；

### 39. 序列化和反序列化，应用场景

- 序列化：把对象转换为字节序列的过程称为对象的序列化
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化
- 应用场景：当对内存中的对象进行持久化（磁盘，数据库）或网络传输，都需要序列化和反序列化；

### 40. Serializable的作用 serialVersionUID的作用

- 当一个类实现了Serializable接口后，就可以将该类的对象转换为字节流进行序列化，或者将字节流转换为对象进行反序列化；
- Java会使用serialVersionUID来验证序列化对象的版本是否与当前类的版本匹配。如果不匹配，就会导致反序列化失败；

### 41. static属性为什么不会被序列化

- static属性优先于对象存在，随着类的加载而加载，所以不会被序列化；

### 42. transient关键字的作用

- 该词修饰的变量，在序列化的时候其值会被忽略，在被反序列化后，变量的值被设为初始值，如int:0,对象型：null；

### 43. 什么是反射，应用场景

- 反射：对于任意类，能知道类的所有属性和方法；对于任意对象，能够调用任意方法和属性；
*应用场景*
- 通过反射可以获取class对象、获取构造器、方法、字段、创建对象。
- 反射类的核心类是java.lang.class 以及 java.lang.reflect.method field constructor;
- JDBC连接数据库使用class.forName()反射加载数据库的驱动程序
- IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法；
- web服务器中利用反射调用sevlet的Service方法；
- jdk动态代理底层依赖反射实现；

### 44. 什么是泛型

- 泛型的本质是数据类型参数化；
- 一般的类和方法，只能使用具体的类型；如果编写可以应用多种类型的代码，会有刻板的限制；
- 泛型类Box<T>
- 通过泛型，编译期间确定类型，保证类型安全；提升可读性；合并了同类型的处理代码提高代码的重用率，增加程序的通用灵活性；

### 45. 如何停止一个正在运行的线程

- 线程只有从runnable状态（可运行或运行状态）才能进入终止状态，如果线程处于休眠状态，需要通过Thread类的interrupt方法，让线程进入runnable状态，从而结束线程;

### 46. 什么是跨域

- 跨域是指某一域名的网页请求另一个域名的资源；由于同源策略，不允许直接访问；场景：前后端分离模式；
- 同源策略：同源 协议+域名+端口三者相同；有利于保护网站信息；

### 47. 跨域问题如何解决

- @CrossOrigin注解：Springboot，在Controller类上添加一个 @CrossOrigin(origins ="*") 注解就可以实现对当前controller 的跨域访问；可以加到方法上，也可加到入口类；
- proxy代理转发：配置代理服务器，将前端请求先发送到代理服务器，代理将请求转发后端服务；前端和代理之间不涉及跨域，代理与后端之间不存在跨域；
- CORS（Cross-Origin Resource Sharing）配置：后端服务可以在响应中添加CORS头部信息来允许特定的跨域请求。在后端接口的响应中添加Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等头部字段，指定允许的来源、HTTP方法和头部信息。这样浏览器在发起跨域请求时会根据这些头部信息进行验证和授权。

### 48. java中引用和cpp指针的区别

- 空指针与空引用：空指针，指向内存地址为0的指针，表示不指向任何有效对象；引用不能为null，可以指向一个空对象；
- 指针运算和引用操作：cpp：指针可以运算，可以直接访问指针指向的内存地址；java：不允许运算，无法直接访问对象的内存地址；
- 内存管理：cpp：指针需要手动进行内存分配和释放，可能导致内存泄漏和悬空指针；java：引用的内存管理由垃圾回收器自动处理，无需手动管理；
- 安全性：cpp:空指针异常、野指针；java：引用不为null；
- 多级指针和引用链：cpp:多级指针实现多级间接访问；java：通过对象的引用链来访问嵌套对象；

## java集合

### 1. 常见的集合有哪些

- 集合主要由接口Collection和Map派生出来，Collection有三个子接口：List、Set、Queue
- List：有序可重复集合，可直接根据元素的索引来访问；可以插入多个null；
- Set：无序不可重复集合，只能根据元素本身来访问；只允许一个null；
- Queue：队列集合
- Map：key-value对的集合，可根据元素key来访问value
- Set Map容器有基于哈希存储和红黑树两种方式实现；
- Set基于Map实现，Set里的元素值就是Map的键值；

### 2. ArrayList是什么，其扩容机制，遍历ArrayList时移除一个元素？

- 动态数组，容量能够动态增长；可以使用ensureCapacity增加ArrayList实例的容量；
- 本质是计算出新的扩容数组的size后实例化，并将原有数组内容赋值到新数组中；原有的数组会被垃圾回收器回收，释放内存空间；ArrayList通常会选择增加一定的空间来避免频繁扩容，以提高性能；
- foreach删除会导致快速失败问题，可以使用迭代器的remove方法；
  Iterator itr = list.iterator();
  itr.remove();

### 3. ArrayList 和 Vector的区别

- 都是存储对象的动态数组；
- ArrayList存储空间连续，不是线程安全的，在内存不够时扩容为原来的1.5倍；Vector扩容为原来的2倍；
- Vector属于线程安全级别，大多数情况下不使用，效率比较低（因为在很多方法上使用了同步）；

### 4. ArrayList和LinkedList的区别

- 前者基于动态数组实现；后者基于链表实现；
- 通过index访问get和set方法，前者查询速度优于后者；前者直接通过数组下标找元素，时间复杂度O(1)；后者需要移动指针遍历元素直到找到为止O(n)；
- 新增和删除元素，后者速度优于前者，前者可能需要扩容和赋值数组O(n)；后者实例化对象后修改指针即可O(1)；

### 5. HashMap

- HashMap使用数组+链表+红黑树实现；链表长度大于8时，会把链表转换为红黑树，红黑树节点个数小于6时才转化为链表，防止频繁的转化；

### 6. 解决Hash冲突的方法？HashMap用的哪种？

- 开放定址法、再哈希法、链地址法；HashMap使用的是链地址法；
- 开放定址法：如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi；开放定址法所需要的Hash表的长度要大于等于所需要存放的元素；只能在删除的节点上做标记，不能。

### 7. hash算法

- 取key的hashCode值，高位运算（减少冲突）、取模运算；
- jdk1.8中，通过hashcode()的高16位异或低16位实现；减少冲突同时不会有太大的开销；

### 8. 为什么建议设置hashMap的容量

- hashmap有扩容机制，达到扩容条件（hashmap中的元素个数超过临界值）就会扩容；
- 如果不设置初始容量大小，随着元素的不断增加，hashmap会发生多次扩容；每次扩容都需要重建hash表，非常影响性能，所以建议初始化hashmap容量；

### 9. 扩容机制

- 1.8扩容机制：当元素个数大于threshold是，使用2倍容量的数组代替原有数组。采用尾插入的方式将原数组元素拷贝到新数组。

### 10. put方法流程

- 如果table没有初始化就先进行初始化
- 使用hash算法计算key的索引
- 判断索引处是否存在元素，没有就直接插入
- 如果存在元素，一种是链表形式直接遍历到尾端插入，另一种是红黑树按照结构插入；
- 链表的数量大于阈值8，就要转换成红黑树的结构
- 添加成功后会检查是否需要扩容

### 11. 红黑树的特点

- 每个节点或是黑色或是红色
- 根节点和叶子节点是黑色的
- 如果一个节点是红色的，则其子节点必须是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

### 12. 解决hash冲突，为什么先用链表，再转红黑树

- 红黑树需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要；
- 链表元素小于8，可以保证查询性能；当元素个数大于8个并且数组容量大于等于64，会采用红黑树；
- 红黑树搜索时间复杂度为O（logn）,链表为O（n），在n比较大的时候，使用红黑树可以加快查询速度；

### 13. hashmap长度为什么是2的幂次方

- 将HashMap的长度定为2的幂次方，这样就可以使用(n - 1)&hash位运算代替%取余的操作，提高性能。

### 14. hashmap默认加载因子是多少，为什么？

- 当元素个数达到容量乘以加载因子时，hashmap将会扩容；
- 0.75是时间空间成本之间的一个平衡；
- 空间多 时间效率要求高，降低负载因子的值；
- 空间紧张 时间效率要求不高，增加负载因子的值，可以大于1；

### 15. 一般用什么作为hashmap的key

- 由于 String 类型是不可变的，并且已经重写了 hashCode() 和 equals() 方法，非常适合作为 HashMap 的 key；
- 例如 Integer、Long、Double 等，这些类也已经重写了 hashCode() 和 equals() 方法
- key用来唯一标识键值对，决定了键值对在hashmap内部的存储位置以及查找方式；

### 16. hashmap为什么线程不安全
- jdk1.7 多线程环境下，扩容可能导致环形链表的出现，形成死循环；
- jdk1.8 多线程环境下，会发生数据覆盖；

## 计算机基础 

### 计算机网络 

### 操作系统 

### 数据库 

### 算法/leetcode

## 真实java面经整理

### 1. websocket是什么

- websocket一种单个TCP连接上进行全双工通信的协议，允许客户端和服务器之间实时双向数据传输；
- 与传统的http请求响应模型不同，websocket通过保持长连接，使得服务器可以主动向客户端推送数据，而不需要客户端先发起请求；

### 2. websocket如何实现

- 建立连接：客户端发送特殊的http握手请求来请求升级到websocket协议；服务器收到请求后，如果支持websocket，就会返回一个带有特定头部信息的http响应，表示协议升级成功；
- 通信数据帧：建立连接后，客户端和服务器之间可以相互发送数据帧（frame），数据帧是 WebSocket 通信的基本单位。数据帧可以分为文本帧和二进制帧，用于在客户端和服务器之间传输数据。
- 保持连接：WebSocket 连接是长期保持的，客户端和服务器之间可以随时发送数据，而不必重新建立连接。这种特性使得 WebSocket 适合于实时通信、在线游戏、消息推送等场景。
- 关闭连接：当通信结束或需要关闭连接时，客户端或服务器可以发送关闭帧（Close frame）来关闭连接。
- 通过 @OnOpen、@OnMessage 和 @OnClose 注解来处理连接建立、消息接收和连接关闭事件。
- 前端vue后端spring实现建立Websocket连接：后端添加Websocket依赖，配置Websocket定义endpoint，创建Controller处理Websocket消息；前端npm安装Websocket客户端库，创建Websocket服务，在组件中使用Websocket服务；

### 3. 分布式锁、乐观锁、悲观锁

- 分布式锁：在分布式环境中，由于存在多个节点同时访问共享资源的情况，需要使用分布式锁来避免数据竞争和并发访问引起的问题。常见的实现方式包括基于数据库、ZooKeeper、Redis等工具。
- 乐观锁：认为并发访问冲突的概率较小，因此在读取数据时不加锁，在更新数据时检查数据版本或时间戳等标识，如果没有发生冲突，则顺利更新数据；如果发生冲突，则进行回滚或重试操作。乐观锁适用于读操作频繁、写操作相对较少的场景。
- 悲观锁：认为并发访问冲突的概率较大，因此在读取数据时就会加锁，以防止其他线程同时修改数据。悲观锁适用于写操作频繁、且并发访问比较密集的场景。

### 4. 分布式锁的具体实现方式

- 基于数据库：通过在数据库中创建一张表或者一条记录来表示锁状态；当一个节点需要获取锁时，会向数据库中插入一条特定的记录，其他节点在尝试获取锁时会受阻；释放锁时，节点会删除或更新数据库中的记录
- 基于缓存：使用缓存系统（如Redis）来实现分布式锁，利用缓存的原子性操作来保证锁的互斥性；当一个节点需要获取锁时，在缓存中设置一个特定的键值对，其他节点在同一时间无法设置相同的键值对；释放锁时，节点删除对应的键值对

### 5. hashmap的底层

- HashMap 的底层结构是一个数组，每个数组元素是一个链表或红黑树的头节点（称为桶）；
- 如果发生哈希冲突（不同键的哈希值映射到相同的桶位），则以链表或红黑树的形式存储在同一桶位上。
- 通过哈希函数和链表/红黑树的结构，可以在常数时间内进行快速的查找、插入和删除操作。
- HashMap 的性能受到哈希碰撞的影响，因此良好的哈希函数和合理的负载因子是保证 HashMap 性能的关键因素。

### 6. 为什么要引入红黑树 红黑树的性质 优点

- 引入红黑树主要是为了解决链表过长时导致的性能问题；
- 优点：平衡性保证了快速的查找、插入和删除；适合动态插入删除的场景；可靠的性能；

### 7. mysql锁

- 锁是用来管理并发访问数据库中数据的机制，它可以确保在多个用户同时访问和修改同一数据时，不会发生数据不一致或丢失更新的情况
- 行级锁：最小的粒度，锁定单独的行，适合高并发环境下对单独行的访问和修改
- 表级锁：锁定整个表，在写操作时会阻塞其他写操作和读操作，适用于较少并发的场景
- 页级锁：锁定数据页，介于行级锁和表级锁之间，不常用

### 8. mysql索引数据结构

- B+ 树，这是一种多路搜索树；
- 平衡性：每个叶子节点到根节点的长度相同，保证了检索的稳定性和效率
- 有序性：B+ 树的内部节点以及叶子节点都是有序的，便于范围查找
- 高扇出：每个节点存储的关键字较多，减少了树的高度，提高了查询效率
- 适合磁盘存储：B+ 树的特性使得它更适合磁盘存储，减少了磁盘 I/O 操作

### 9. B+树和红黑树的区别

- B+树适合磁盘存储，支持范围查询和排序操作；红黑树适合内存存储，适合频繁插入和删除操作。
- B+树是多路平衡查找树，数据存储在叶子节点上；红黑树是自平衡二叉查找树，节点包含数据。
- B+树的节点包含大量的关键字，适合高扇出；红黑树的节点包含数据，适合较小规模的数据集。

### 10. 创建索引需要考虑些什么

- 选择合适的列
- 避免过度索引：会占用额外的存储空间
- 考虑索引的顺序：对于涉及多个列的查询，考虑创建复合索引
- 注意数据类型：索引的数据类型应尽可能小，以减少存储空间和提高查询效率
- 定期维护索引

### 11. 如何优化索引

- 使用覆盖索引：尽量让查询能够通过索引完成，减少回表查询，提高查询效率
- 避免在索引列上使用函数：如果在索引列上使用函数操作，可能会导致无法使用索引，应尽量避免这种情况。
- 分析查询执行计划：通过分析查询执行计划，可以了解查询的性能瓶颈，有针对性地进行索引优化
- 使用索引提示：在某些情况下，数据库优化器可能无法正确选择最优的索引，可以使用索引提示来指导优化器选择合适的索引
- 监控索引的使用情况：通过数据库的性能监控工具，可以实时监控索引的使用情况和性能表现，及时调整索引策略

### 12. mysql引擎有什么

- 存储引擎（Storage Engine）是负责管理数据存储和检索的模块，它定义了数据如何存储、检索、索引和处理
- InnoDB 是 MySQL 的默认存储引擎，它支持事务、行级锁、外键约束等高级功能，适合于大多数 OLTP（联机事务处理）应用;InnoDB 支持 ACID（原子性、一致性、隔离性、持久性）特性，提供高度的数据完整性和并发控制
- MyISAM 是 MySQL 中最早的存储引擎，不支持事务和行级锁，但适合于读密集的应用;MyISAM 对于表级锁定，适用于一些非事务性的应用，例如数据仓库等
- MEMORY 存储引擎将表中的数据存储在内存中，适合于临时表、缓存等需要快速访问的场景;由于数据存储在内存中，速度很快，但在重启数据库或发生崩溃时，数据会丢失

### 13. 数据库 事务的四大特性

- ACID
- 原子性（Atomicity）：原子性指数据库事务是一个不可分割的工作单位，要么全部执行成功，要么全部失败回滚。
- 一致性（Consistency）：一致性指数据库事务将数据库从一个一致性状态转变为另一个一致性状态。
- 隔离性（Isolation）：隔离性指数据库系统在执行多个事务时，要求每个事务的操作互相独立，彼此之间不会产生影响。
- 持久性（Durability）：持久性指一旦事务提交，其所做的修改将会永久保存在数据库中，并对其他事务和外部故障具有持久影响。

### 14. 使用innodb的表数据结构存储方式

- 聚簇索引：InnoDB 表中的数据是按照主键顺序存储的，这就意味着数据实际上是按照主键顺序排列的。因此，InnoDB 表中的主键实际上是一个聚簇索引
- 辅助索引：除了主键索引外，InnoDB 表可以有多个辅助索引（即普通索引）。每个辅助索引都会包含索引字段和指向对应行的主键值，通过主键值再去找到对应的行数据。
- 数据页：InnoDB 使用固定大小的数据页（通常为 16KB）来存储数据，并且通过 B+ 树数据结构来组织这些数据页。这种方式有利于高效地进行范围查找和范围扫描操作。
- 行格式：InnoDB 表中的行数据存储格式可以是 COMPACT 或者 REDUNDANT。COMPACT 格式适用于普通的业务表，它对行数据进行了紧凑的存储和压缩；而 REDUNDANT 格式则用于历史遗留的表，它保留了更多的额外信息。
- MVCC：InnoDB 使用多版本并发控制（MVCC）来支持事务的隔离级别，这意味着每行数据都会维护多个版本，以便实现事务的并发访问。

### 15. 索引什么情况下会失效

- 使用函数或表达式进行查询
- 字段进行了隐式类型转换
- 对字段进行了 NULL 值判断
- 数据量较小的表
- 字段上存在大量重复值
- 索引未被合理利用

### 16. mysql中一条数据的查询过程

- 构建查询语句
- 发送查询请求：通过 MySQL 客户端（如命令行工具、MySQL Workbench 等）或者编程语言的数据库连接库，发送构建好的 SQL 查询语句到 MySQL 数据库服务。
- MySQL 数据库处理查询：MySQL 数据库接收到查询请求后，会解析查询语句，执行相应的查询操作
- 执行查询计划：MySQL 数据库根据查询语句中的条件和索引等信息，生成查询执行计划，决定如何最有效地执行该查询。
- 执行查询操作：MySQL 数据库按照生成的查询执行计划执行查询操作，检索满足条件的数据。
- 返回结果集：一旦查询操作完成，MySQL 数据库将查询结果作为结果集返回给发起查询请求的客户端
- 客户端处理结果：客户端接收到查询结果后，可以对结果进行进一步的处理和展示，比如在命令行工具中打印结果，或者在应用程序中进行数据处理和展示。

### 17. map和hashmap

- Map是一种用于存储键值对的数据结构，允许通过键来查找值。而HashMap是Map接口的一个具体实现类，基于哈希表实现
- Map接口表示映射表，其中的键和值都可以是任意类型;Map中的键是唯一的，每个键最多只能映射到一个值;
- HashMap是基于哈希表实现的Map接口的一个类;HashMap允许存储null键和null值;HashMap不保证键值对的顺序，即不保证遍历顺序和插入顺序一致;在大多数情况下，HashMap的插入、删除和查找操作的时间复杂度为O(1)
- hashmap相较于map的优势：快速的查找和插入操作；允许存储null键值；无序性（不保证键值对的顺序）；扩展性（拉链法解决哈希冲突）；

### 18. hashmap，链表长度大于8时，链表换成红黑树

- 当链表过长时，在查找某个键值对时可能需要遍历整个链表，导致查找效率降低。而红黑树作为一种自平衡的二叉查找树，可以保证在最坏情况下的搜索时间复杂度为O(log n)，相比链表有更快的查找速度

### 19. 说说缓存一致性，业界常用解决方案是什么

- 缓存一致性是指在分布式系统中，确保不同节点上的缓存数据与后端数据的一致性;引入缓存提高读性能，不用每次都从数据库读数据；缓存中间件：redis,性能高，提供很多友好的数据类型;
- 缓存利用率最大化：先读缓存，如果缓存不存在，则从数据库读取，并重建缓存；同时写入缓存的数据都设置失效时间，只保留“热数据”；
- 业界解决方案：强一致性：2PC、3PC、Paxos、Raft分布式一致性算法;弱一致性；最终一致性
- 缓存失效策略：通过设置合适的缓存失效策略来保证数据的及时更新。例如，可以设置缓存数据在一定时间后自动失效，或者在数据发生变化时手动将缓存标记为失效。
- 读写锁机制：在并发读写场景下，引入读写锁机制可以有效地控制对缓存数据的访问，避免脏数据的产生。
- 发布订阅模式：通过发布订阅模式，当后端数据发生变化时，及时通知各个缓存节点进行数据更新，保持数据的一致性。
- 版本号控制：每次数据更新时增加一个版本号，缓存节点在获取数据时同时获取版本号，当版本号不一致时触发数据更新。
- 缓存代理：引入缓存代理层，负责管理缓存数据和后端数据之间的同步，实现数据的一致性。
- 写后读一致性：在数据更新后，保证后续的读操作都能获取到最新的数据，可以通过延迟失效、写完后立即更新缓存等方式实现。

### 20.进程线程区别

- 进程（Process）是指计算机中正在运行的一个程序实例。例如，打开的微信就是一个进程；
- 线程（Thread）称为轻量级进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等；
- 一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈；
- 线程和进程最大的不同在于基本上各进程是独立的，而同一进程中的线程极有可能会相互影响；线程执行开销小，但不利于资源的管理和保护；而进程正相反。

### 21.进程切换开销

- 进程切换：从正在运行的进程中，收回CPU的使用权利，交给下一个要运行的进程；
- 进程切换开销大原因：保存和恢复上下文（CPU 寄存器、程序计数器、堆栈指针）、虚拟内存的切换、页表的更新（虚拟内存地址与物理内存地址之间的映射关系）、进程调度算法。

### 22.线程阻塞

- 线程阻塞是指线程暂时停止执行，等待某种条件满足或者某个事件发生后才能继续执行的状态；
- 线程阻塞原因：I/O阻塞、锁阻塞、条件变量阻塞、信号阻塞；

### 23.进程通信方法

- 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。用户空间和内核空间都属于内存。
- 管道(Pipe)：管道是一种半双工的通信方式，它通过一个文件描述符连接两个进程，一个进程通过管道的写端写入数据，另一个进程通过管道的读端读取数据。管道通常用于具有父子关系的进程之间进行通信。
- 命名管道(Named Pipe)：命名管道是一种具有名称的管道，它可以在无关的进程之间进行通信。与普通管道不同的是，命名管道在文件系统中有一个路径名，并且可以通过这个路径名进行访问。
- 信号(Signal)：信号是一种异步的通信方式，用于通知进程发生了某个事件。比如，当进程收到 SIGINT 信号时，表示用户按下了中断键(Ctrl+C)，进程可以捕获这个信号并执行相应的处理逻辑。
- 消息队列(Message Queue)：消息队列是一种在进程间传递数据的通信方式，它允许一个进程向另一个进程发送消息，并且可以实现进程间的同步和异步通信。
- 共享内存(Shared Memory)：共享内存允许多个进程访问同一块内存区域，这样它们可以直接读写共享的数据，而不需要进行复制或者通过中间介质进行通信。共享内存通常用于需要高效率的数据交换场景。
- 信号量(Semaphore)：信号量是一种用于实现进程间同步和互斥的机制，它可以用来保护共享资源的访问顺序，防止多个进程同时访问共享资源导致的数据不一致问题。
- 套接字(Socket)：套接字是一种在网络上进行进程间通信的通用方式，它可以在同一台主机上的不同进程之间通信，也可以在不同主机上的进程之间通信。套接字通常用于实现客户端-服务器模式的网络通信。

### 24.GET和POST请求区别

***GET 请求：*** 

- 通过 URL 向服务器传递参数，参数会以键值对的形式附加在 URL 的末尾，例如：http://example.com/path?param1=value1&param2=value2。
- 请求参数有长度限制，受浏览器和服务器限制，通常在 2KB 到 8KB 之间，因此 GET 请求适合传输较少量的数据。
- GET 请求会将请求参数显示在浏览器地址栏中，因此不适合传输敏感信息，如密码等。
- GET 请求可被缓存，可被书签收藏，可被历史记录保留，以及可被浏览器记录，因此不适合用于传输敏感信息。

***POST 请求：***

- 通过 HTTP 请求的 body 传递参数，参数不会显示在 URL 中，而是隐式地通过 HTTP 报文体传递。
- 请求参数的长度理论上没有限制，但受服务器配置的限制，通常可以传输更大量的数据。
- POST 请求适合传输较多量的数据，因此常用于提交表单、上传文件等操作。
- POST 请求对请求参数的格式没有限制，可以传输二进制数据，而 GET 请求的参数则通常是 URL 编码的文本。
- POST 请求不会被缓存，不会被书签收藏，不会被历史记录保留，以及不会被浏览器记录，因此更适合用于传输敏感信息。

### 25.JAVA EE技术

- JavaEE 号称有十三种核心技术。它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。

### 26.多线程会产生哪些并发问题

- 竞态条件：多个线程并发执行，对共享资源的访问顺序不确定，导致最终结果与预期不一致；此问题是由于缺少同步机制，可以通过枷锁或使用院子操作来避免；
- 内存可见性：一个线程修改了共享变量的值，其它线程不能立即查看修改后的值；通过使用volatile关键字或显式同步操作（锁、synchronized关键字、原子变量等）来解决；
- 死锁：多个线程互相持有对方所需的资源，导致这些线程都被阻塞，无法继续执行；
- 活锁：多个线程都在等待对方执行完毕，导致无法继续执行，一直在忙碌；
- 饿死：一个线程无法获取所需的资源而一直无法执行，一直处于等待状态；

### 27.SSM框架 Spring+SpringMVC+MyBatis

### 28.Spring和SpringBoot

***Spring***

- 配置繁琐；依赖繁琐
- java开发框架，多模块的集合；
- Core container核心容器：主要提供对IOC依赖注入的支持；
- AOP：提供了面向切面的编程实现；
- Data Access/Integration 数据访问/继承：该层提供了与数据库交互的支持（Spring-jdbc, spring-tx, spring-orm, spring-oxm, spring-jms）
- Web：提供支持创建Web应用程序的模块（Spring-web, spring-webmvc, spring-websocket, spring-webflux）
- Test：提供Junit单元测试，TestNG等；

***SpringBoot***

- SpringBoot一个简化Spring应用开发的框架；
- 约定优于配置；
- 自动配置；起步依赖，是一个Maven项目对象模型POM；辅助功能，如嵌入式服务器；
- SpringBoot继承父工程；
- 引导类，SpringBoot项目的入口；
- 启动依赖：spring-boot-starter-parent（组合了一套最优的技术版本） spring-boot-starter-web(依赖传递)
- IOC容器负责创建、初始化、配置和销毁对象Bean；
- @Conditional根据特定条件来决定是否创建一个bean；
- spring boot内置四种web服务器，导入不同依赖坐标实现默认web服务器（tomcat）的切换；
- @Enable用于启用特定功能或配置的元注解；
- spring boot不能获取第三方jar包中的Bean，@import（四种用法）导入的类会被加载到IOC容器中；
- @EnableAutoConfiguration，约定大于配置，通过分析项目的依赖关系和当前运行环境，自动配置应用程序所需要的各种组件、框架和功能。首先，扫描classpath上的依赖；其次，使用条件化配置conditional确定需要应用的配置；然后，自动配置；最后，启动器？
- SpringBoot自带监控功能actuator(http请求返回json数据)、Admin图形界面（需要在client中指定Server地址）;

### Bean作用域

- bean的作用域定义了Spring容器如何创建bean实例以及如何管理bean的生命周期；
- singleton单例，默认作用域。对于此类，ioc容器只创建一个bean实例，无论请求多少次，总是返回一个bean实例的引用；（减少对象创建的开销）
- prototype原型，每次请求或主义时，Spring容器都会创建一个新的bean实例；（提供更大的灵活性，会增加更多的内存和处理开销）
- request，每次http请求都会创建一个新的bean，仅在当前http请求内有效。
- session，每次http会话都会创建一个新的bean，仅在当前http会话内有效。
- application，在ServletContext的生命周期内，为每个ServletContext创建一个bean实例。此作用域仅在基于Servlet的Web应用程序中有效；
- Websocket，在WebSocket生命周期内，为每个WebSocket创建一个bean实例。此作用域仅在支持WebSocket的Spring应用程序上下文中有效；

### Mybatis占位符$()和#()的区别

- 两种主要的SQL占位符$()和#(),在SQL语句中用于替换参数；
- #（）预处理语句占位符，推荐，可以有效防止SQL注入攻击；传入的参数会被处理为预处理语句的参数占位符，自动将参数值绑定到SQL语句上；预处理语句会把SQL语句和参数分开处理，有助于数据库预编译SQL，提高执行效率，并且可以防止恶意构造的SQL语句；
- $ () 字符串替换占位符，Mybatis会将传入的参数直接替换到SQL语句中相应的位置；如果传入的参数包含SQL代码，可能会被执行，从而引发安全问题；适用于动态表名、列名、排序字段等场景；

### Spring IOC

- IOC（控制反转，inversion of control）核心特性。负责管理应用程序中对象的创建、配置、组装以及它们的生命周期。（自动装配、作用域管理、生命周期回调）
- 核心概念是将对象的创建以及它们之间的依赖关系管理从应用程序代码中分离出来，交由IOC容器来处理；从而降低耦合度、提高模块化、易于测试、灵活的配置、生命周期管理；
- Spring ioc工作原理：注册bean，通过配置告诉ioc容器如何创建对象bean以及它们的依赖关系；Spring ioc容器负责将bean的依赖关系注入到bean中；管理bean的生命周期，包括初始化和销毁。

### 工厂模式、bean依赖关系、依赖注入

- 工厂模式是一种软件设计模式，目的是封装对象的创建过程，使得能够在不指定具体类的情况下，能够通过一个共同的接口来创建对象；工厂模式的特点：封装性、接口、扩展性；
- bean依赖关系，指的是一个bean需要其他bean来正常工作的情况；例如一个服务类bean需要一个数据访问对象Dao bean来访问数据库；
- 依赖注入允许开发者将组件所依赖的外部资源注入到组件中，而不是由组件自己创建或查找这些资源。
- 依赖注入的类型:构造器注入和setter注入；
- 依赖注入的实现
  - xml配置：通过property标签来指定bean的属性和依赖；
  - 注解，使用Spring的注解，如@Autowired和@Inject，来标注需要注入依赖的字段、构造器或setter方法；
  - Java配置：通过Java配置类和@Bean注解来配置bean和它们的依赖；
```
public class UserDao {
    // 数据访问逻辑
}

public class UserService {
    private UserDao userDao;

    // setter注入
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    // 构造器注入
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    // 业务逻辑
}
```
```
<!-- XML配置 -->
<bean id="userDao" class="com.example.UserDao"/>
<bean id="userService" class="com.example.UserService">
    <property name="userDao" ref="userDao"/>
</bean>
```
```
@Configuration
public class AppConfig {
    @Bean
    public UserDao userDao() {
        return new UserDao();
    }

    @Bean
    public UserService userService(UserDao userDao) {
        UserService service = new UserService();
        service.setUserDao(userDao);
        return service;
    }
}
```


### 29.SpringBoot配置文件

- 两种方式，application.properties、yml、yaml（优先级依次降低，双引号识别转义字符、单引号忽略转义字符）；
- 读取配置内容：@Value、Environment、@ConfigurationProperties；
- profile激活配置文件；

### 30.消息队列在微服务中的应用

- 作为中介实现了服务间的异步通信，降低了服务间的耦合度，使得服务可以更加独立地升级和扩展；
- 通过队列暂存消息，消息队列能够实现流量削峰，提高系统的稳定性；
- 消息队列还支持动态扩展服务实例，提高了系统的处理能力；

### 31.RabbitMQ 与 Kafka

- 消息队列系统
- RabbitMQ：适用于实时性要求较高、消息量较小的场景。例如，订单处理、日志收集等。RabbitMQ的优点在于配置简单、易于管理；但在处理大量数据时，性能可能会受到限制。
- Kafka：适用于大数据量、高吞吐量的场景。如日志分析、实时数据监控等。Kafka的优点在于高性能、高可靠性；但配置相对复杂，学习成本较高。

### 32.web实时消息推送

- 短轮询，指定时间间隔，由浏览器向服务器发送HTTP请求，服务器实时返回数据给客户端；（JS定时器可以实现）；频繁的网络请求、服务器负载高、延迟、实时性差；
- 长轮询，客户端向服务器发送请求，服务器保持连接打开，当有新数据时立即响应，或在一定时间内无数据时才响应，减少不必要的网络开销，提高实时性和效率，但连接保持会占用服务器资源和连接数；
- 服务器发送事件（SSE），服务端向客户端单向消息推送（ChatGPT，在计算过程中持续返回数据，避免等待时间过长而选择关闭页面），基于HTTP协议（服务端无法主动向客户端推送消息）；开发成本低、支持断线重连、单向通信；实现方式：前端进行HTTP请求、建立连接、监听服务端推送，后端创建连接、给指定用户发送消息；
- Websocket，在TCP连接上的全双工通信协议，客户端和服务端仅需一次握手，两者就可以创建持久性的连接；工作过程：客户端发送HTTP请求，请求头包含upgrade：Websocket和sec-websocket-key字段，表示升级协议；服务器接收请求并回复HTTP101状态码，响应头包含connection：upgrade和sec-websocket-accept字段；客户端和服务端建立Websocket连接，数据以帧形式传送，每条消息会被切分成多个数据帧，接收端重组成完整的消息；客户端或服务端可以主动发送关闭帧，表示断开连接，另一方收到后也会回复一个关闭帧，然后关闭TCP连接。

### 33.TCP三次和四次握手

***TCP建立连接***

- 一次握手：客户端发送SYN（SEQ=x）标志的数据包给服务端，然后客户端SYN_SEND等待服务器的确认；服务端确认客户端发送正常，自己接收正常；
- 二次握手：服务端发送带有SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包给客户端，然后服务端进入SYN_RECV状态；客户端确认自己发送接收正常，对方发送接收正常；服务端确认对方发送正常，自己接收正常；
- 三次握手：客户端发送ACK(ACK=y+1) 标志的数据包给服务端，然后客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。客户端确认自己发送接收正常，对方发送接收正常；服务端确认自己发送接收正常，对方发送接收正常；
- 三次握手的目的是建立可靠的通信信道，确认双方的发送与接收是正常的。

***第二次握手为什么要传回SYN***

- ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，回传 SYN 则是为了建立并确认从服务端到客户端的通信；
- 为了建立可靠的TCP连接；

***断开连接***

- 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 FIN-WAIT-1 状态。
- 第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。
- 只要四次挥手没有结束，客户端和服务端就可以继续传输数据！

***为什么要四次挥手？***

- TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

***为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？***

- 因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

***如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？***

- 客户端没有收到 ACK 确认，会重新发送 FIN 请求。

***为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？***

- 第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

### 33.java反射机制

- Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
- Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。
- 注解的实现也用到了反射机制；

### 34.Docker

- 一种实现容器技术的工具；
- 可以打包一个应用及依赖包到一个轻量级、可移植的容器中；
- 为了解决单机部署应用和虚拟化的局限性而诞生；
- 资源占用少、启动快；

***容器***

- 容器镜像是轻量的、可执行的独立软件包，包含软件运行所需要的所有内容：代码、运行时环境、系统工具、系统库和设置；
- 容器化软件在任何环境（Linux、Windows）中都能够始终如一地运行；容器赋予了软件独立性，减少了相同基础设施上运行不同软件时的冲突；
- 不同容器之间是相互隔离，独立运行的；
- 通常一个容器就是一个应用或服务（微服务）；

***容器状态***

- 运行、退出、暂停、健康、非健康；

***镜像***

- 镜像是创建容器的模板；
- 同一个模板可以创建多个不同的容器；
- 容器是镜像生成的运行实例；
- 仓库存放镜像，主机通过仓库下载镜像，通过镜像创建容器；

***常用命令***

- docker import 加载镜像
- docker tag 修改镜像的完整标识符（名称：版本）
- docker run -it 创建容器并运行，(-it参数)进入bash可交互终端中
- docker images 列出当前系统所有镜像
- docker ps -a 列出所有docker容器
- docker exec 进入容器内部
- docker inspect 查看镜像信息（端口映射）
- docker cp 实现主机和容器内部文件的拷贝；通过dockerjava依赖包可以实现java和容器的交互；

***容器随着docker启动而启动？修改端口映射？***

- --restart=always
- -p指定端口映射


***虚拟化***

- 资源占用多，每个虚拟机都是完整的操作系统，需要分配大量的系统资源；
- 冗余步骤多；
- 启动慢；

### 35.Nginx

- HTTP/HTTPS反向代理、负载均衡、静态站点、文件服务器
- 特点：高性能、高并发处理、低内存消耗、事件驱动架构、模块化设计以及良好的可靠性和稳定性；
- web服务器：nginx（主流）、apache

***nginx如何实现反向代理***

- 反向代理：以代理服务器来接收Internet的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外相当于反向代理服务器；
- 实现步骤：配置监听端口，用于接收客户端的请求；指定一个或多个后端服务器，这些服务器实际处理客户端的请求；设置代理规则（HTTP头部请求、SSL终止、静态资源、负载均衡、限制请求、Websocket支持），告诉nginx如何将请求转发给后端服务器；

***负载均衡***

- 网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流；
- nginx配置文件中定义了upstream块，列出所有的后端服务器；选择负载均衡方法；在Server模块中使用proxy_pass将请求转发到定义的upstream组；配置额外的代理设置；
- 负载均衡策略：轮询、加权轮询、最少连接(将请求分配给连接数最少得服务器)、加权最少连接、IP Hash（根据IP地址进行哈希，确保同一IP的请求总是发送到同一个服务器）、普通 Hash（根据请求的URI进行哈希，以平衡请求分布）

***网站有多个webapp的配置***

- 问题描述：网站有多个webapp，分别绑定不同的端口号；
- nginx可以根据请求的URL将请求转发到不同的后端应用程序；

***静态站点***

- 仅由HTML、CSS、JavaScript文件组成，以及可能的图像和其他媒体文件，不涉及服务器端的数据库交互和动态内容处理；
- 配置静态站点（html文件和一堆静态资源）

```java
location / {
			root /app/dist;
			index index.html;
			#转发任何请求到 index.html
		}
```

***文件服务器***

- 归档一些数据或资料，使用nginx可以快速搭建简易的文件服务；

```java
autoindex on;# 显示目录
autoindex_exact_size on;# 显示文件大小
autoindex_localtime on;# 显示文件时间

server {
    charset      utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解
    listen       9050 default_server;
    listen       [::]:9050 default_server;
    server_name  _;
    root         /share/fs; #会从root目录开始查找请求的资源
}
```

***解决跨域***

- 前后端分析，独立的web app互相访问，存在跨域问题；
- CORS，在后端服务器设置HTTP响应头，把你需要允许访问的域名加入Access-Control-Allow-Origin中
- jsonp，把后端根据请求，构造 json 数据，并返回，前端用 jsonp 跨域。
- nginx，首先在 enable-cors.conf 文件中设置 cors，然后在你的服务器中 include enable-cors.conf 来引入跨域配置；




### 36.HTTP和HTTPS的区别

***http***

- hyper text transfer protocol超文本传输协议，超文本指的是包括文本在内的各式各样的消息；
- http应用层协议，以TCP（输出层）作为底层协议，默认端口80；
- 优点：扩展性强、速度快、跨平台支持性好；缺点：安全性低；

***https***

- hyper text transfer protocol secure，基于http和tcp，并额外使用SSL/TLS协议用作加密和安全认证，默认端口443；
- SSL通道常使用基于秘钥的加密算法，密钥长度通常40比特和128比特；
- 优点：保密性好、信任度高；缺点：消耗更多服务器资源；

***SSL***

- Secure Sockets Layer安全套接字协议，TLS基于SSL；
- 非对称加密，采用两个密钥，公钥和私钥；利用公钥加密，利用私钥解密；公私钥的生成算法依赖于单向陷门函数；计算代价较高，效率太低；
- 对称加密，通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性；
- 通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。

### 37.http状态码

- http状态码用于描述http请求结果
- 1XX：信息性状态码，接收的请求正在处理，平时不会碰到；
- 2XX：成功状态码，请求正常处理完毕；
  - 200 OK：请求被成功处理，例如查询用户信息；
  - 201 Created：请求被成功处理，例如创建新用户；
  - 202 Accepted：服务端接收到了请求，但还未处理；
  - 204 No Content：成功处理请求，但没有返回任何内容；
- 3XX：重定向状态码，需要进行附加操作以完成请求；
  - 301 永久重定向，例如网址更换；
  - 302 临时重定向，例如网站资源暂时转移到另一网址；
- 4XX：客户端错误状态码，服务器无法处理请求；
  - 400 bad request：发送的http请求存在问题，例如参数不合法，请求方法错误；
  - 401 unauthorized：未认证却请求需要认证后才能访问的资源；
  - 403 forbidden：拒绝http请求，一般针对非法请求；
  - 404 not found：请求资源未在服务端找到，比如请求某个用户的信息，服务端没有找到；
  - 409 conflict：请求的资源与服务端当前的状态存在冲突；
- 5XX：服务器错误状态码，服务器处理请求出错；
  - 500 internal Server error：服务端出问题了，例如服务端处理请求时突然抛出异常，但异常在服务端未被正确处理；
  - 502 bad gateway：网关将请求转发到服务端，但服务端返回的是一个错误的响应；

### 38.什么是redis

- 基于c语言开发的开源NoSQL数据库。数据保存在内存中，支持持久化，因此读写速度快，被广泛应用于分布式缓存方向。并且存储的是KV键值对数据，键是唯一的字符串标识符，值可以是String、list、Set、Hash、ZSet。
- 应用广泛：缓存、分布式锁、限流、消息队列、延时队列；

***redis的作用***

- 加速读写：例如MySQL的存储层通常读写性能不够强悍，通过缓存的使用可以有效地加快读写，优化用户体验；
- 降低后端负载：帮助后端减少访问量和复杂计算（例如复杂的SQL语句），很大程度上降低了后端的负载；

***redis和关系型数据库的区别***

- redis存储键值对数据；关系型数据库存储结构化数据（表格形式）；
- redis数据存储在内存，读写速度快；关系型数据库数据存储在硬盘上，可以通过索引和优化来提升性能；
- redis提供了数据持久化选项，可以将内存中的数据定期或按需写入磁盘；关系型数据库数据本身就存储在磁盘上；
- redis支持简单的事务，不支持多行事务或复杂的事务空间；关系型数据库提供强大的事务支持，包括ACID（原子性、一致性、隔离性、持久性）；（事务指的是操作各种数据项的一个数据库操作序列）；
- redis查询功能相对简单，主要通过键来访问数据；关系型数据库提供丰富的SQL查询语句，支持复杂的数据查询、连接、聚合和子查询等操作；
- redis在单线程模型下运行，保证了操作的原子性，在分布式环境中需要额外的机制来保证数据一致性；关系型数据库通过锁和事务机制来保证数据的一致性和隔离性；
- redis适合用作缓存、会话存储、排行榜、实时分析、消息队列等场景；关系型数据库适合需要复杂查询、事务处理、数据完整性保证的应用程序，如金融系统、企业资源规划（ERP）等；

***redis为什么快***

- 基于内存；
- 基于 Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路复用；
- 内置了多种优化过后的数据类型/结构实现，性能非常高；
- 通信协议实现简单且解析高效；

***分布式系统***

- 由多个计算机节点通过网络连接而成的系统，这些节点可以是物理上分散在不同地理位置的计算机，也可以是虚拟机或容器。

***缓存***

- 用redis实现缓存；
- 缓存用于提高数据访问速度，减少延迟，并通过减少对主存储或数据库的访问次数来提高系统性能。缓存的工作原理是将频繁访问的数据存储在快速、低成本的存储介质中，以便快速检索。
- 把数据库中的部分数据转移到缓存中，这样用户的部分请求直接到缓存不用经过数据库，从而提高系统整体的开发；

***缓存读写策略***

- 旁路缓存模式：
  - 写：先更新db；然后直接删cache；
  - 读：从cache中读取数据，读取到就直接返回；cache中读取不到，就从db中读取数据返回；再把数据放到cache中；
- 读写穿透：
  - 写：先查 cache，cache 中不存在，直接更新 db；cache 中存在，则先更新 cache，然后 cache 服务自己更新 db；
  - 读：从 cache 中读取数据，读取到就直接返回；读取不到的话，先从 db 加载，写入到 cache 后返回响应；
- 异步缓存写入：
  - 适合对数据一致性没那么高的场景；

***redis实现分布式锁***

- 分布式锁用于协调多个进程或线程访问共享资源；分布式锁确保同一时间只有一个进程可以执行特定的操作或访问特定的资源；
- 分布式锁的核心在于互斥；
- 通过SETNX命令加锁；基于Lua脚本释放锁（Lua脚本保证了解释操作的原子性）；为了避免锁无法被释放，需要设置过期时间；操作共享资源的操作未完成，锁过期时间需要续期（解决方案：Redisson）；
- Redisson中的分布式锁自带自动续期机制

***redis如何实现持久化***

- 持久化：数据在系统断电或崩溃后依然能够保持并再次使用的能力，数据被存储在某种非易失性存储介质；Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；
- RDB（redis database backup） 持久化：RDB 是将 Redis 在内存中的数据以快照的形式保存到磁盘上的一种持久化方式。当启用 RDB 持久化时，Redis 会根据配置的策略定期将数据保存到磁盘上的一个文件中。RDB 文件是一个二进制文件，包含了 Redis 在某个时间点上的数据快照。RDB 持久化适用于备份和恢复数据，以及在数据量较大时，通过定期生成快照文件可以减少恢复时的数据恢复时间。
- AOF（append only file） 持久化：AOF 是将 Redis 的写操作以追加的方式记录到一个文件中的一种持久化方式。当启用 AOF 持久化时，Redis 会将每个写操作记录到 AOF 文件的末尾。这样做的好处是可以确保每个写操作都被持久化，从而最大程度地避免数据丢失。

***redis实现延时任务***

- redisson内置的延时队列，redisson是基于java的redis客户端库，与redis是客户端和服务器的关系；减少了丢消息的可能、消息不存在重复消费问题；

***redis数据类型***

- 5 种基础数据类型：String（字符串）、List（列表，双向链表）、Set（集合）、Hash（散列，键值对）、Zset（有序集合，通过跳跃表实现，跳跃表：在有序单链表的基础上，每个节点具有随机的索引层数）
- 3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)

***redis内存管理策略***

- 设置最大内存限制，如何达到这个限制，redis根据配置策略来决定如何处理新数据的写入；
- 内存使用策略：
	-  noeviction：默认行为，返回错误，拒绝写入操作；
	-  volatile-lru: 在设置了过期时间的键中，根据最近最少使用LRU原则移除数据；
	-  allkeys-random：在所有键中，随机选择并删除数据。
	-  volatile-random：在设置了过期时间的键中，随机选择并删除数据。

***微服务***

- 将大型复杂软件应用分解为一系列小型、松散耦合、功能独立的服务。每个微服务围绕特性的业务功能构建，拥有自己的数据库、代码库和运行环境，通过轻量级的通信机制（HTTP RESTful API）与其他服务交互；
- 单一职责原则（高内聚低耦合）；独立部署；技术多样性；业务驱动；去中心化治理；敏捷性；容错性；可维护性；可测试性；服务发现；Api网管；持续集成和持续部署；

### 39.Knife4j

***简介***

- Knife4j 是一个为 Java MVC 框架集成 Swagger 生成 Api 文档的增强解决方案，其前身是 swagger-bootstrap-ui。

***核心功能***

- 文档说明：接口地址、类型、请求示例、参数、响应示例、参数、响应码等信息；
- 在线调试；
- 参数校验；
- 兼容性；
- 界面友好；

***使用步骤***

- 引入依赖；
- 配置Swagger注解；
- 启动项目/doc.html路劲访问；
- 查看和测试接口；

### 40.Threejs

- Three.js是一个基于JavaScript的开源3D图形库，用于创建和显示各种3D场景和动画。它建立在WebGL之上，简化了在网页上使用3D图形技术的复杂性，使开发者能够轻松地在浏览器中创建交互式的3D内容。
- 使用步骤：创建三维空间场景；创建相机（观察点、观察方向、角度）；创建渲染器；创建物体、光源，并添加到场景中；通过渲染器将场景、相机渲染到页面上；

### 41.聚簇索引与非聚簇索引

- 索引是一种提高数据检索速度的数据结构；类似于书籍的目录，允许快速定位到特定的数据记录，而不需要逐行读取数据表中的每个记录。

***聚簇索引***

- 聚簇索引即索引结构和数据一起存放的索引，例如主键索引。在MySQL中，InnoDB引擎的表的.ibd文件就包含了该表的索引和数据，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
- ibd文件就包含了该表的索引和数据；
- 优点：查询速度快、对排序查找和范围查找优化；
- 缺点：依赖于有序的数据、更新代价大（因此书剑一般不可被修改）；

***非聚簇索引***

- 索引结构和数据分开存放的索引，并不是一种单独的索引类型，例如二级索引（辅助索引）；MySQL的MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。
- .MYD文件包含表的数据、.MYI文件包含表的索引；
- 优点：更新代价比聚簇索引小；
- 缺点：依赖于有序的数据、可能会二次查询（回表，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询）；

### 42.B+树

- 全称多路平衡查找树，大部分数据库系统及文件系统都采用B或B+树作为索引结构；

***B树***

- B树的所有节点既存放key也存放data;
- 叶子结点独立；
- 检索过程相当于二分查找，没到达叶子节点，检索就结束了；
- 范围查询时，需要先找到下限，后中序遍历，找到上限；

***B+树***

- 只有叶子节点存放key和data，其它节点只存放key;
- 叶子节点有一条引用链指向与它相邻的叶子节点；
- 检索效率稳定，任何查找都需要从根节点到叶子节点；
- 对链表进行遍历即可；
- 相比于B树，具备更少的IO次数（查找数据所需的树高较小）、更稳定的查询效率和更适合于范围查询；

### 43.JVM垃圾回收

- Java自动内存管理核心的功能是堆内存中对象的回收和分配；
- 对象创建：堆内存被分为三个部分：新生代内存（Eden、s0、s1，大多数新创建的对象被分配在这里）、老生代（Tenured，当对象在新生代经历一定数量的垃圾回收后仍然存活，它们将会被晋升到老年代）、永久代(MetaSpace，用于存放类信息、常量池)；
- 垃圾识别：JVM通过跟踪对象的引用情况来识别垃圾。只要对象能够通过一系列名为“GC Roots”的根对象被引用，它就被认为是活跃的。GC Roots通常包括线程的局部变量、静态变量、全局变量等；
- 垃圾回收算法：
  - 标记-清除（Mark-Sweep）：首先通过可达性标记垃圾，然后遍历整个堆内存将没有标记的对象进行回收。
  - 复制（Copying）：将内存分为两个区域（from区 to区），垃圾回收过程中，将所有存活的对象从一个区域复制到另一个区域，然后清理原区域中的所有对象。避免了内存碎片化，但是需要额外的内存空间用于复制对象。
  - 标记-压缩（Mark-Compact）：结合了标记-清除和复制算法的优点。先标记需要回收的对象，然后将存活的对象向堆的一端移动以压缩内存，最后清理堆末端的所有无效对象，以减少内存碎片。
  - 分代收集（Generational Collection）：基于对象生命周期的不同，将堆分为新生代和老年代，分别采用不同的策略进行垃圾回收。新生代中的对象存活率较低，适合使用复制算法（效率较高的垃圾回收算法）；老年代中的对象存活率较高，适合使用标记-压缩算法（保守的垃圾回收算法）。
- 垃圾回收触发：大多数情况下，对象在新生代中Eden区分配；当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC；当老年代空间不足时会触发Full GC;
- 垃圾回收器：JVM提供了多种垃圾回收器，如Serial、ParNew、CMS、G1等，它们采用不同的策略和算法来优化垃圾回收的性能和延迟；

### JVM内存空间

- JVM启动时创建内存空间，内存空间包含元空间（常量池、字符串常量池、类的元数据：类名、方法名、修饰符、方法、属性）、堆内存（新生代、老年代）、本地方法栈、程序计数器（用于存储当前线程正在执行的字节码指令的地址）；
- 垃圾收集器（garbage collector，GC）实现垃圾识别和回收；垃圾识别方式：引用次数法（根据每个对象被引用的次数确定对象是否可以被回收）、可达性分析（从一组称为"GC ROOTS"对象开始遍历对象之间的引用关系，识别出活跃对象，那些无法通过任何路径与"GC ROOTS"相连的对象被认为是不可达的，即垃圾对象）；
- Minor GC主要针对堆内存中的新生代区域，使用执行效率较高的垃圾回收算法，例如复制算法。Full GC针对老年代区域，对整个堆空间进行垃圾回收，使用保守的垃圾回收算法。



### 45.插入排序、选择排序、快速排序、堆排序

- 插入排序：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直到整个序列有序为止；
- 选择排序（最大最小值排序）：每一次从待排序的数据元素中选出最小或最大的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完；
- 快速排序：从数列中取出一个数作为基准数，分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边，再对左右区间重复第二步，直到各区间只有一个数；
- 堆排序：可以利用数组的特点快速定位指定索引的元素，适合处理大量数据的排序问题；
- 冒泡排序：通过重复遍历要排序的数列，比较每对相邻元素，如果它们顺序错误就把它们交换过来。重复过程直到没有需要交换的元素为止。

### 46.动态规划DP

- 通常用于解决具有重叠子问题和最优子结构性质的问题

### 47.全双工、半双工、单工

- 全双工：可以同时进行双向数据传输；
- 半双工：允许信号在两个方向上传输，但某一时刻只允许信号在一个信道上单向传输；
- 单工：只支持在一个方向上传输；

### 48.OSI七层模型、TCP/IP五层模型以及各层的代表协议

- TCP/IP
  - 物理层：具体的物理媒介和物理设备
    - 传输单位：比特
    - 硬件：集线器、中继器
  - 数据链路层：负责在物理层面上传输数据
    - 传输单位：帧
    - 硬件：交换机、网桥
  - 网络层：负载在不同网络之间传输数据，实现了不同网络之间的互联
    - 传输单位：分组
    - 硬件：路由器
    - 协议：IP、ARP地址解析协议、ICMP网际报文控制协议
  - 传输层：提供端到端的可靠数据传输和错误恢复功能
    - 传输单位：报文段（TCP） 用户数据段（UDP）
    - 协议：TCP、UDP
  - 应用层：直接为应用程序提供服务的层
    - 传输单位：报文
    - 协议：DHC动态主机配置协议、DNS域名解析协议、HTTP、HTTPS、FTP、SMTP

- OSI
  - 应用层被细分成了：会话层+表示层+应用层
  - 会话层：负责建立、管理和终止会话
    - 协议：RPC（远程过程调用）、NFS（网络文件系统）
  - 表示层：负责数据的加密、压缩、格式转换等
    - 协议：JPEG、MPEG
  - 应用层：提供各种服务、如电子邮件、文件传输、远程登录
    - 协议：HTTP、FTP、SMTP

### 49.操作系统的组成部分

- kernel内核：OS的核心部分，直接控制着计算机的各种硬件资源；包括进程管理、内存管理、文件系统、设备驱动程序等模块；
- 进程管理：负责管理计算机系统重的各个进程，包括进程的创建、运行、调度、挂起、恢复和终止等操作；
- 内存管理：负责管理计算机系统中的内存资源，包括内存的分配、回收、映射等操作；
- 文件系统：负责管理计算机系统中的文件和目录，包括文件的创建、读取、写入、删除等操作；
- 设备驱动程序：负责管理计算机系统中各种硬件设备，包括输入设备、输出设备、网络设备等。设备驱动程序是与硬件设备直接交互的程序，通过设备驱动程序可以将软件和硬件之间的接口进行连接。
- 用户界面：操作系统提供给用户的交互界面，通常包括命令行界面和图形用户界面等。用户通过用户界面与操作系统进行交互，完成各种操作。

### 50.数据库三范式

- 帮助我们规划结构合理
- 第一范式1NF：确保每列都是不可拆分的；
- 第二范式2NF：在1NF基础上，确保非主键列完全依赖于主键，而不是依赖于主键的一部分；
- 第三范式3NF：在2NF基础上，确保非主键列不存在传递依赖；

### 51.面向对象的理解

- 对象是客观存在的事务，可以说任何客观存在的都是可以成为对象；
- 抽象：对同一类型的对象的共同属性和行为进行概括，形成类。由类构造对象的过程称为创建类的实例；
- 封装：将抽象出的数据、代码封装在一起，隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性；
- 继承：在已有类的基础上，进行扩展形成新的类，提高代码复用性。继承是多态的前提；
- 多态：多态就是同一函数名具有不同的功能实现方法；
- 面向过程是具体的，流程化的；面向对象是模型化的，抽象出一个类（封闭的盒子），拥有数据和方法，需要什么功能直接使用；

### 52.实例方法和静态方法的区别

- 实例方法是指对象的方法，需要通过对象来调用；实例方法可以访问该对象的所有属性和方法；在实例方法内部，可以使用关键字this来引用当前对象；
- 静态方法是指类的方法，不需要通过对象来调用，可以直接使用类名来调用。静态方法不能访问实例属性和方法，只能访问静态属性和方法；
- 类加载时刻的初始化顺序：类被加载到JVM中，静态方法会被初始化，而实例方法并不会初始化，只有类实例化后才会被调用；
- 调用静态方法是，可以直接使用类名调用；调用实例方法是，需要先创建类的实例对象，通过实例对象来调用；

### 53.java中父类和子类的静态代码块、非静态代码块、构造方法的执行顺序是怎么样的

- 父类静态代码块
- 子类静态代码块
- 父类非静态代码块
- 父类构造方法
- 子类非静态代码块
- 子类构造方法

### 54.什么是继承？java是单继承还是多继承？为什么用单继承？

- 继承：允许一个类从另一个类继承属性和方法。被继承的类成为父类，继承这些属性和方法的被称为子类；java中继承关系使用关键字extends来标识；
- java中只能单继承，原因：如果一个子类拥有多个父类，那么父类中有重复的属性或者方法时，子类的调用结果就会含糊不清，存在二义性；同时多继承会增加代码的耦合性，导致代码的可维护性和可扩展性降低。但是可以通过接口实现多重继承的效果，接口是一个特殊的抽象类，只定义了一组抽象方法和常量，不包含实现代码。

### 55.什么是抽象类？什么是接口？抽象类和接口的适用场景是什么？

- 抽象类：包含一个或多个抽象方法的类就是抽象类，抽象方法即没有方法体的方法，抽象方法和抽象类都必须声明为abstract。抽象类还可以包含具体数据和具体方法。抽象类不能被实例化；如果创建一个继承抽象类的非抽象子类，那么必须为父类的所有抽象方法提供方法定义。
```
public abstract class Person{
  public abstract String getDescription();
}
```
- 抽象类适用场景：当多个子类具有共同的方法实现时，可以将共同的方法实现放在抽象类中，由子类继承并扩展各自方法，模版方法模式就是抽象类的一个典型应用。抽象类不能实例化可以增强程序的安全性。
- 接口本质也是一个类，相比于抽象类不能包含具体方法，接口中的方法将自动被设置为public类型，属性被自动设置为public static final类型；接口可以被多继承；
- 接口适用场景：多个类具有相同的行为规范时，可以定义一个接口；接口可以用来实现回调机制，将方法作为参数传递给其他方法使用。

### 56.java中的数据类型及所占字节和取值范围

***整数***
- byte 1字节
- short 2字节
- int 4字节
- long 8字节
***浮点数类型***
- float 4字节
- double 8字节
***布尔类型***
- boolean 单独使用，使用int数据类型代替，占4个字节；数组形式，则占1个字节；
***字符类型***
- char 2字节

### 57.什么是多态？运行时多态和编译时多态？重载和重写的区别？
- 多态：同一个方法调用在不同的对象实例上具有不同的行为；多态发生的三个必要条件：继承、方法重写/覆盖、父类引用指向子类对象；
- 当把一个子类对象直接赋给父类引用变量时，例如Parent p=new Child()，p引用变量的编译时类型是Parent，而运行时类型是Child；
- 运行时多态：也称为动态绑定或方法重写，指程序运行时，根据对象的实际类型确定使用哪个方法的过程。这种多态通过继承和方法重写实现；
- 编译时多态：也称为静态绑定或方法重载，程序编译时，根据方法的名称、参数类型和返回值类型确定使用哪个方法的过程，这种多态性通过方法重载实现。
- 重载和重写的区别：重写是父类与子类之间多态性的表现，方法重写，只有方法体是不一样的，子类返回类型可以是父类方法返回类型的子类型，访问权限可以有限制的修改，子类的访问权限不能比父类的严格。方法重载并非多态的必要条件，一个类中定义了多个方法名相同，但是参数的数量或者类型不同的方法，方法的返回类型和访问权限可以任意修改。

### 58.线程池是什么，线程池的重要参数

- 线程池是一种线程使用模式，线程池中包含了一定数量的线程，实现线程复用，主要目的是减少线程创建和销毁所花费的时间；
- 重要参数：
  - corePoolSize: 核心线程数量，决定了线程池中始终保持的线程数量；
  - maximumPoolSize: 最大线程数量，限制了线程池可达到的最大线程数量；
  - workQueue: 任务队列，用于缓存待执行的任务；
  - rejectedExecutionHandler: 拒绝策略，当任务太多，无法被线程池及时处理时，采取的策略；（默认拒绝策略，任务被拒绝后会抛出异常；调用者运行策略，调用者线程（指提交任务到线程池的线程，通常是应用程序的主线程）运行被拒绝的任务；丢弃策略，任务被忽略不做任何处理；丢弃最旧任务策略，会丢弃队列中最旧的任务，然后尝试再次提交当前任务）
  - keepAliveTime: 非核心线程空闲时的存活时间；
  - timeUnit: 存活时间的时间单位；
  - threadFactory：线程工厂，用于创建新线程的工厂；

### 59.java类加载机制、Java类的全生命周期、JVM内存

 '''类加载机制'''

- 加载：将Java类字节码加载到JVM内存中，静态数据结构加载到方法区中，类对象java.lang.class加载到堆中;
- 连接：
  - 验证：验证加载的文件是否符合JVM规范；
  - 准备：为静态变量分配内存，设置默认初始值；
  - 解析：将符号引用转换成直接引用；
- 初始化：静态变量的赋值操作和执行类的静态初始化代码块```static{ }```；

 '''类全生命周期'''

- 加载阶段；
- 链接阶段：包括验证、准备、解析；
- 初始化阶段；
- 使用阶段：类可以被应用程序使用，类的属性和方法可以被访问和执行；
- 卸载阶段：当类不再被使用时，JVM的垃圾回收器会回收这个类的内存；

 '''JVM内存'''

- 方法区（元空间）：存储已被JVM加载的类信息、常量、静态变量等；
- 堆：JVM中最大的一块内存区域，存储对象实例和数组；堆是所有线程共享的内存区域；堆内存分为新生代和老年代；
- 虚拟机栈：每个线程创建时都会创建一个虚拟机栈，用于存储局部变量表、操作栈、动态链接、方法出口等信息；
- 程序计数器：用于存储指向下一条指令的地址；线程私有的，每个线程都有个独立的程序计数器；
- 本地方法栈：存储本地方法（java以外语言编写的方法，调用操作系统层面的功能）的调用状态；线程私有；

### 60.常见的垃圾回收器

- Serial (新生代，标记复制法) + Serial Old (老年代，标记整理法) 单线程收集器，需要暂停用户线程
- Parallel Scavenge（新生代，标记复制法） + Parallel Old（老年代，标记整理法） 多线程收集器，暂停用户线程
- ParNew（新生代，标记复制法） + CMS（老年代，标记清除法+标记整理法） Serial收集器的多线程版本
- G1 （分代收集，针对新生代使用标记复制，针对老年代使用标记压缩）多线程，默认的垃圾回收器，将堆内存划分为多个相等大小的区域，每个区域可以用于年轻代或老年代，允许G1 GC动态调整年轻代和老年代的大小；增量式收集；
- ZGC （整个堆内存，并发标记法）多线程
- Minor GC：快速，设计年轻代，频繁发生；Major GC：涉及老年代，通常比MinorGC慢；Full GC：涉及整个堆，触发条件（老年代内存不足、元空间不足、显示调用）；

### 61.常见的垃圾回收算法

- 标记-清除：遍历所有根对象，标记从根对象可达的对象，清除未被标记的对象。（内存碎片问题严重）
- 标记-复制：将内存划分为两个区域，当一个区域满了之后，将存活的对象复制到另一区域，然后清除第一个区域的所有对象。（空间利用率低）
- 标记-整理：标记存活的对象后，将所有存活的对象向内存的一端移动，然后清除边界以外的所有空间。（效率比较低）
- 分代算法，将内存空间分为新生代、老年代，新生代使用标记复制算法，老年代使用标记整理算法。

## 谷粒商城
### 1.lombok简化Bean开发
### 2.mybatisx使mapper定位到xml文件

### 3.SpringCloud alibaba nacos
### 4.openfeign实现远程调用

## 大数据开发
### 数据存储
- Hadoop中 HDFS管理多个服务器上的数据，处理存储 MapReduce并行计算（分布式处理程序） map阶段将计算任务进行分配 reduce阶段将计算结果进行汇总；
- sql on hadoop:impala presto Hive在Hadoop进行结构化处理的解决方案，将sql语句翻译成MapReduce程序；
- Spark计算框架（streaming流处理 机器学习MLlib 图处理graphx） 基于内存的计算 速度快 MapReduce基于磁盘的计算；
- Flink主要用于流式计算（实时计算） Spark/Hive批式计算（离线计算）

## 中兴金篆面经

### 1.Spring Boot 和Spring的区别

- spring是服务端开发框架，核心是IOC（控制反转）和AOP（面向切面编程），IOC容器的具体实现是BeanFactory用于管理Bean对象的创建的销毁，spring在运行时动态的创建对象并调用对象的方法，IOC的实现涉及到了JAVA的反射机制（程序运行时加载类的详细信息，从而操作类或对象的属性和方法）。
- springboot是基于spring的框架，通过“约定大于配置”的原则，简化spring应用的搭建和开发。通过starter启动依赖简化了Maven依赖配置；内嵌了tomcat、jetty等http服务器，不需要部署WAR文件；提供了默认配置，减少了配置工作。

### 2.Mysql的特性，默认的innodb和Myisam的区别
- Mysql是开源免费的关系型数据库，社区活跃，支持分库分表，读写分离，支持的数据类型包括数值型、字符串型和日期时间型三大类，支持事务满足ACID原则（原子性、一致性、隔离性、持久性）。
- innodb支持事务、myisam不支持事务；
- innodb支持外键，myisam不支持外键
- innodb支持行级锁，更适合并发处理，myisam只支持表锁；
- innodb支持MVCC（行级锁的升级），myisam不支持；
- 数据库崩溃时，innodb可以使用redo log命令恢复到崩溃前的状态，myisam不可以；
- innodb的性能比myisam更好；
- innodb（数据文件本身就是索引文件）和myisam（索引文件和数据文件分离）的索引结构都采用B+树，但是实现方式不同；

### 3.Mybatis如何保证数据库的安全性

- 通过#{}参数绑定，或者通过preparedStatement类来实现预编译，防止SQL注入攻击；
- mybatis提供对数据库连接信息（mpw:开始的配置项为加密内容）和数据库字段信息进行加密（使用AES算法生成随机密钥2对敏感数据进行加密）；

### 4.Mybatis实现对数据库的操作

- plus在application.yml或者properties中配置数据库源以及mybatis相关配置；
- 定义实体类entity，使用mybatis-plus提供的注解映射数据库表；
- 编写Mapper层接口，在resources下的xml编写复杂查询、多表联合的相关SQL语句；
- 在Controller和Service层中调用Mapper中的接口。

### 5.Mysql遇到性能瓶颈如何解决

- 建立索引，加速查询速度，避免多余的索引影响写操作的速度；
- where语句中避免对索引字段使用函数，这会导致无法有效使用索引；
- 利用redis建立缓存，对频繁读取但更新频率低的数据进行缓存，降低数据库的访问压力；
- 读写分离，主数据库对数据进行写操作，从数据库复制主数据库对数据进行读操作；
- 针对大量数据，进行分库分表；

### 6.Mysql数据库断电了怎么办

- 查看数据库的错误日志；
- 数据库重启后会进入修复状态，使用redo log重复执行已提交的事务，使用undo log回滚未提交的事务；
- 尝试修复数据库之前，备份重要的数据；

### 7.Springboot后端服务器遇到瓶颈怎么解决

- springboot自带的tomcat服务器可能无法处理高并发请求，可以通过设置server.tomcat.threads.max增加最大工作线程数；
- 增加JVM的-Xms初始堆内存大小和-Xmx最大堆内存大小，避免频繁的垃圾回收和内存溢出；
- 使用nginx实现负载均衡，将请求分配到多个后端服务器上，降低负载；

### 8.jdk1.7和jdk1.8的区别

- jdk1.8引入了全新的日期和时间api；
- jdk1.8支持lambda表达式，允许以更简单的方法表示匿名函数，使用集合操作和并发操作更简单；

### 9.序列化和反序列化的作用是什么，什么场景需要用到

- 序列化，将对象信息转成字节流，存储到文件系统或者在网络中进行传输；反序列化，将字节流信息反序列化为对象；
- 持久化磁盘，将对象存储到磁盘需要进行序列化；在分布式系统中，需要将对象序列化用于网络传输到其他节点；将对象存储到缓存中需要进行序列化；在大数据开发中（spark、hive）需要将对象进行序列化；将对象作为消息发送到消息队列中，需要序列化；

### 10.如何设计Mysql中的表

- 理解需要，根据应用程序的需求，确定表的用途，使用频率，查询方式；
- 创建表的关系，绘制实体-关系图（E-R图）确定表之间的关系，确定实体、属性、关系；
- 确定字段的数据类型，避免过大的数据类型占用太多空间；
- 确定唯一不变的主键；
- 创建合适的索引，从而提升查询效率；
- 增加约束条件，例如not null等保证表的完整性；

### 11.java多线程

- 多线程是指在java程序上可以实现多个线程的同时执行，实现并发操作，提高程序的执行效率；
- java中提供两种实现多线程的方法，第一种是集成Thread类，第二种是将实现Runable接口作为Thread类的参数，这样既可以继承别的类也能实现多线程。

### 12.java中如何读取json文件

- jackson 
`
import com.fasterxml.jackson.databind.ObjectMapper
ObjectMapper mapper=new ObjectMapper();
mapper.readValue(File file,Object.class)
`
- gson
`
import com.google.gson.Gson;
Gson gson=new Gson();
gson.fromJson(FileReader reader,Object.class)
`

### 13.springboot 自动配置机制如何实现
- @EnableAutoConfiguration作为自动配置的入口，该注解基于classpath中的jar依赖为应用自动配置；
- spring-boot-autoconfigure模块中包含了所有自动配置类，这些类通过条件注解决定是否应用某个自动配置；
- @Conditional条件注解决定是否创建一个Bean；
- application。properties/yml通过这些配置文件设置属性，可以覆盖自动配置的默认值；

### 14.springboot如何引入外部配置
- 设置命令行参数；
- @Value注解，通过@Value注解直接注入值；
- 环境变量；
- properties>yml,通过properties或yml文件的方式，通过spring.profiles.active激活指定profile配置文件；

### 15.线程创建方式

- 继承Thread类的子类，创建子类的实例，并调用其start方法（根据是否分配了cpu时间片而处于就绪状态和运行状态）；
- 	局限：Java不支持多重继承，如果已经继承了别的类，就不能继承Thread类来创建线程；
- 创建实现了runnable接口的类，创建类的实例，并作为参数传递给Thread类的构造函数，然后调用其start方法；
- 	推荐，一个类可以实现多个接口，不需要继承Thread类；
- 创建实现callable接口的类，实现call方法，使用futureTask类来包装callable对象，并将futureTask对象作为参数传递给Thread构造函数；
- 	callable的call方法可以返回结果和抛出异常，而runnable不能；

### 桥梁健康监测项目遇到的问题

```场景```
- 实时通信：需要服务器与客户端之间进行实时数据交换的场景，如在线游戏、实时聊天应用和实时数据更新。
- 减少延迟：在传统的HTTP请求中，每次请求都需要建立新的连接，这会导致额外的延迟。WebSocket通过持久连接减少了这种延迟。
- 减少服务器负载：传统的基于HTTP的长轮询或短轮询会频繁地在客户端和服务器之间发起连接请求，增加了服务器的负载。WebSocket通过保持连接来减少这种负载。
- 双向通信：需要服务器主动向客户端推送信息的场景，如股票行情更新、新闻订阅服务等。
解决的问题
- 减少连接开销：传统的HTTP连接在每次请求后都会关闭，而WebSocket建立一次连接后可以持续通信，减少了频繁建立和关闭连接的开销。
- 避免HTTP头部的重复传输：在HTTP请求中，每个请求和响应都需要传输完整的头部信息。WebSocket在建立连接后，数据传输不需要传输头部信息，减少了数据量。
- 实现真正的实时性：HTTP请求无法实现真正的实时通信，因为它们是请求-响应模式的。WebSocket提供了真正的全双工通信，服务器可以随时向客户端推送数据。
- 改善用户体验：通过减少延迟和提高通信效率，WebSocket可以改善用户在实时应用中的体验。
降低编程复杂性：与长轮询或短轮询相比，WebSocket的编程模型更简单，开发者可以更轻松地实现实时通信功能。
- 跨域通信：WebSocket支持跨域通信，使得客户端可以与不同域的服务器建立通信连接。
```WebSocket的工作原理```
- 建立连接：客户端通过发送一个特殊的HTTP请求来发起WebSocket连接请求，服务器响应请求并切换到WebSocket协议。
- 数据传输：一旦连接建立，客户端和服务器之间就可以通过这个持久的连接进行数据传输。
- 连接关闭：当通信结束时，任何一方都可以发起关闭连接的请求。

### HTTP请求

- 请求行：请求方法、请求URL、HTTP版本；
	- 请求方法：GET POST PUT DELETE HEAD OPTIONS PATCH； 
- 请求头：客户端类型、认证信息、请求的内容类型（content-type）；
- 请求正文：内容类型和格式由content-type请求头指定；



### 16.spring cloud微服务组件

- 服务注册中心和配置中心：nacos
	- 允许服务实例向注册中心注册自己的ip地址、端口号等信息，允许服务实例在运行时查找其他服务;
	- 集中化管理应用的配置信息，允许在不重启服务的情况下修改配置；
- 服务网关：gateway
	- 路由转发：根据请求的URL将请求转发到正确的微服务；
	- 负载均衡：将请求分发到多个相同的微服务实例；
	- 请求认证：对请求进行身份验证和授权；
	- 请求聚合：将多个微服务的响应合并成一个响应返回给客户端；
	- 限流与熔断：保护下游服务免受过载影响。 	
- 服务间通信：Feign
	-  声明式的HTTP客户端，简化了HTTP请求的开发；
	-  同步调用：通过HTTP/RESTful API等协议进行直接调用；
	-  异步消息队列：通过消息队列进行异步通信；
- 服务容错与断路器：Sentinel
	- 故障隔离：防止一个服务的问题影响整个系统；
	- 快速失败：当服务不可用时快速返回错误，而不是等待超时；
	- 恢复策略：当依赖服务恢复正常时，自动重试调用。	 

### 17.消息队列

- 基本概念：消息生产者 消息队列 消息消费者
- 作用：
	- 解耦，实现应用程序之间的解耦；
	- 异步处理，生产者无需等待消费者是否处理完消息即可继续工作；
	- 负载均衡，多个消费者可以共享同一个队列从而分散处理压力；
	- 容错机制，消息队列可以作为缓冲区，在系统出现问题时保存消息； 
- RabbitMQ
	-  特点：集群部署、支持多种消息传递模式、支持多种语言、提供Web管理界面和REST API；
	-  如何实现：安装rabbitmq、创建连接、声明队列、发送消息、接收消息；
	-  简单消息模式：用于点对点通信，生产者发消息，消费者取，并从队列中移除；每条消息只能被一个消费者消费，如果多个消费者监听同一个队列，也只会被其中一个消费者接收；如果消费者没有确认消息，消息会被重新发送；
	-  发布订阅模式：消息可以被多个消费者同时接收；消息被发送到主题上，而不是发送到队列中；所有订阅该主题的消费者都会受到这条消息；发布者不需要关心消息是否被消费；

### 18.如果从一百万条数据中查询前十条最大的值，使用什么算法

- 最小堆
- 初始化一个大小为K的最小堆，将前k个元素插入堆中；
- 遍历剩余元素，如果该元素大于堆顶元素，则将替换并重新调整堆；
- 最终堆中的元素就是前k个最大值；

### 19.数据库索引

- 定义：索引是对数据库表中一列或多列值进行排序的一种结构；
- 作用：提高查询速度、唯一性约束（主键索引确保每一行数据都是唯一的）、加快排序和分组操作；
- 缺点：占用存储空间、影响写入性能、需要定期维护；
- 索引类型：
	- 单列索引：基于表中的一个列建立索引；
	- 复合索引：基于表中多个列创建的索引；
	- 唯一索引：确保索引列中的值是唯一的；
	- 聚簇索引： innodb使用主键作为聚簇索引。将数据行按照索引键的顺序存储在磁盘上。数据行本身按照索引的顺序存储；
	- 非聚簇索引：索引条目包含索引键和指向数据行的指针；
- 索引数据结构：B+树 平衡的多路搜索树
	- 支持高效地范围查询和顺序访问；
	- 所有叶子节点都在同一层；
	- 每个节点最多包含2n个子节点，最少包含n/2个子节点；
	- 每个节点包含指向相邻节点的指针；

### 20.聚簇索引和非聚簇索引的优缺点

- 聚簇索引：查询速度快，因为数据行本身就是按照索引的顺序存储；非聚簇索引：查询速度慢，需要额外的查找来定位实际的数据行；
- 聚簇：写入性能差，每次插入更新删除都需要调整数据行的存储位置；非聚簇：写入性能好，只需要更新索引条目，不需要调整数据行的存储位置。

### 21.外键的缺点

- 外键约束下，对数据库的增删改会导致额外的锁定，从而影响性能；
- 外键约束在大规模数据集上的开销很大；
- 级联删除问题，删除主表的一条记录，与该记录外键关联的从表记录也会被删除；
- 耦合高、迁移麻烦：主表从表之间相互耦合。

### 22.数据库联表查询

- 内连接 inner join：返回两个表中存在匹配的所有行；
- 左连接left join：返回所有左表的行，如果右表没有匹配的行，则右表字段显示null；
- 右连接right join:返回所有右表的行，如果左表没有匹配的行，则左表字段显示null；
- 全连接full join:返回左表和右表的所有行，对于没有关联记录的行，相应的列显示null；
- 交叉连接cross join:返回左表中的每一行与右表中的每一行的组合（返回所有组合类型）；

### 23.Java中如何将array转成list

- array：基础数据结构，固定大小，类型一致性，内存连续性；
- list：接口，由不同的实现类支持（ArrayList、LinkedList等），动态大小，类型灵活性（可以存储不同类型的数据），功能丰富（提供添加、删除、插入等功能），安全性（列表可以使用泛型来确保类型安全）；
- 转换方式：
	- Arrays.asList()   不能对list增删，只能查改;
	- 将Arrays.asList(myArray)的返回值作为参数传给Arraylist构造器，支持增删改查;
	- 已有LIst对象，使用Collections.addAll()方法将数组元素填充这个列表，最高效；
	- 使用Stream流API将数组转成列表，优点是可以结合其他流操作如过滤、映射等。

### 24.设计模式

- 设计模式：一系列面对软件开发中常见问题的通用解决方案。可以分为三大类，创建型模式（创关注对象的创建机制）、结构型模式（关注类和对象的组合）、行为型模式（关注对象之间的通信和职责分配）。
- 单例模式：一个类只有一个实例，并提供一个全局访问点；
```
// 饿汉模式，立即加载，初始化时就产生实例，缺点：占用资源，优点：线程安全
public SingletionHungary{
	private static SingletionHungary sh=new SingletonHungary();
	//将构造器设置为private禁止通过new进行实例化
	private SingletionHungary(){}
	public static SingletionHungary getInstance(){return singletionHungary;}
}
```
```
// 懒汉式，每次调用getInstance方法时都需要同步
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
- 工厂模式：定义一个创建对象的接口，
- 工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
- 代理设计模式 : Spring AOP 功能的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。
- 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
- 适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller

### java类对象如何去重

- 使用hashset，重写equals和hashcode方法（每个java类都是Object的子类，默认具备这些方法），默认的equals方法比较的是对象的引用是否相同即内存地址，改写后通过比较类对象的属性是否相同，将类对象的属性作为参数生成hash码用于快速查找集合中的元素。